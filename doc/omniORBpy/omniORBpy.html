<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>omniORBpy</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea omniORBpy -->
<!--CUT DEF chapter 1 --><DIV CLASS="center"><P> <FONT SIZE=7>The omniORBpy version 3<BR>
User&#X2019;s Guide
</FONT></P><P> <FONT SIZE=5>Duncan Grisby<BR>
</FONT><FONT SIZE=3>(</FONT><FONT SIZE=3><I>email: </I></FONT><A HREF="mailto:dgrisby@apasphere.com"><FONT SIZE=3><I><FONT COLOR=purple>dgrisby@apasphere.com</FONT></I></FONT></A><FONT SIZE=3>)</FONT><FONT SIZE=5><BR>
Apasphere Ltd.<BR>
</FONT></P><P>July 2009
</P></DIV><P><FONT SIZE=5><B>Changes and Additions, June 2007</B></FONT>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Updates for omniORBpy 3.1.
</LI></UL><P><FONT SIZE=5><B>Changes and Additions, June 2005</B></FONT>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
New omniORBpy 3 features.
</LI></UL><P><FONT SIZE=5><B>Changes and Additions, July 2004</B></FONT>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Minor updates.
</LI></UL><P><FONT SIZE=5><B>Changes and Additions, November 2002</B></FONT>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Per thread timeouts.
</LI><LI CLASS="li-itemize">Minor fixes.
</LI></UL><P><FONT SIZE=5><B>Changes and Additions, August 2002</B></FONT>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Updated to omniORBpy 2.
</LI></UL><P><FONT SIZE=5><B>Contents</B></FONT></P><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>omniORBpy is an Object Request Broker (ORB) that implements the CORBA
2.6 Python mapping&#XA0;[<A HREF="#pythonmapping">OMG01b</A>]. It works in conjunction with
omniORB for C++, version 4.1.</P><P>This user guide tells you how to use omniORBpy to develop CORBA
applications using Python. It assumes a basic understanding of CORBA,
and of the Python mapping. Unlike most CORBA standards, the Python
mapping document is small, and quite easy to follow.</P><P>This manual contains all you need to know about omniORB in order to
use omniORBpy. Some sections are repeated from the omniORB manual.</P><P>In this chapter, we give an overview of the main features of omniORBpy
and what you need to do to setup your environment to run it.</P><!--TOC section Features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;Features</H2><!--SEC END --><!--TOC subsection Multithreading-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">1.1.1</A>&#XA0;&#XA0;Multithreading</H3><!--SEC END --><P>omniORB is fully multithreaded. To achieve low call overhead,
unnecessary call-multiplexing is eliminated. With the default
policies, there is at most one call in-flight in each communication
channel between two address spaces at any one time. To do this without
limiting the level of concurrency, new channels connecting the two
address spaces are created on demand and cached when there are
concurrent calls in progress. Each channel is served by a dedicated
thread. This arrangement provides maximal concurrency and eliminates
any thread switching in either of the address spaces to process a
call. Furthermore, to maximise the throughput in processing large call
arguments, large data elements are sent as soon as they are processed
while the other arguments are being marshalled. With GIOP 1.2, large
messages are fragmented, so the marshaller can start transmission
before it knows how large the entire message will be.</P><P>From version 4.0 onwards, omniORB also supports a flexible thread
pooling policy, and supports sending multiple interleaved calls on a
single connection. This policy leads to a small amount of additional
call overhead, compared to the default thread per connection model,
but allows omniORB to scale to extremely large numbers of concurrent
clients.</P><!--TOC subsection Portability-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">1.1.2</A>&#XA0;&#XA0;Portability</H3><!--SEC END --><P>omniORB has always been designed to be portable. It runs on many
flavours of Unix, Windows, several embedded operating systems, and
relatively obscure systems such as OpenVMS and Fujitsu-Siemens BS2000.
It is designed to be easy to port to new platforms. The IDL to C++
mapping for all target platforms is the same.</P><!--TOC subsection Missing features-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">1.1.3</A>&#XA0;&#XA0;Missing features</H3><!--SEC END --><P>
<A NAME="sec:missing"></A></P><P>omniORB is not (yet) a complete implementation of the CORBA 2.6 core.
The following is a list of the most significant missing features.</P><UL CLASS="itemize"><LI CLASS="li-itemize">omniORB does not have its own Interface Repository. However, it
can act as a client to an IfR. The omniifr project
(<A HREF="http://omniifr.sourceforge.net/"><TT>http://omniifr.sourceforge.net/</TT></A>) aims to create an IfR for
omniORB.</LI><LI CLASS="li-itemize">omniORB supports interceptors, but not the standard Portable
Interceptor API. Interceptor facilities available from Python code are
quite limited.</LI></UL><P>These features may be implemented in the short to medium term. It is
best to check out the latest status on the omniORB home page
(<A HREF="http://omniorb.sourceforge.net/"><TT>http://omniorb.sourceforge.net/</TT></A>).</P><!--TOC section Setting up your environment-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.2</A>&#XA0;&#XA0;Setting up your environment</H2><!--SEC END --><P>
<A NAME="sec:setup"></A></P><P>omniORBpy relies on the omniORB C++ libraries. If you are building
from source, you must first build omniORB itself, as detailed in the
omniORB documentation. After that, you can build the omniORBpy
distribution, according to the instructions in the release notes.</P><!--TOC subsection Paths-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">1.2.1</A>&#XA0;&#XA0;Paths</H3><!--SEC END --><P>With an Autoconf build (the norm on Unix platforms), omniORBpy is
usually installed into a location that Python will find it.</P><P>Otherwise, you must tell Python where to find it. You must add two
directories to the <TT>PYTHONPATH</TT> environment variable. The
<TT>lib/python</TT> directory contains platform-independent Python code;
the <TT>lib/</TT><TT>$</TT><TT>FARCH</TT> directory contains
platform-specific binaries, where <TT>FARCH</TT> is the name of
your platform, such as <TT>x86_win32</TT>.</P><P>On Unix platforms, set <TT>PYTHONPATH</TT> with a command like:</P><PRE CLASS="verbatim">   export PYTHONPATH=$PYTHONPATH:$TOP/lib/python:$TOP/lib/$FARCH
</PRE><P>On Windows, use</P><PRE CLASS="verbatim">   set PYTHONPATH=%PYTHONPATH%;%TOP%\lib\python;%TOP%\lib\x86_win32
</PRE><P>(Where the <TT>TOP</TT> environment variable is the root of your
omniORB tree.)</P><P>You should also add the <TT>bin/</TT><TT>$</TT><TT>FARCH</TT> directory
to your <TT>PATH</TT>, so you can run the IDL compiler, omniidl.
Finally, add the <TT>lib/</TT><TT>$</TT><TT>FARCH</TT> directory to
<TT>LD_LIBRARY_PATH</TT>, so the omniORB core library can be found.</P><!--TOC subsection Configuration file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">1.2.2</A>&#XA0;&#XA0;Configuration file</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">On Unix platforms, the omniORB runtime looks for the environment
variable <TT>OMNIORB_CONFIG</TT>. If this variable is defined, it
contains the pathname of the omniORB configuration file. If the
variable is not set, omniORB will use the compiled-in pathname to
locate the file (by default <TT>/etc/omniORB.cfg</TT>).</LI><LI CLASS="li-itemize">On Win32 platforms (Windows NT, 2000, 95, 98), omniORB first
checks the environment variable <TT>OMNIORB_CONFIG</TT> to obtain the
pathname of the configuration file. If this is not set, it then
attempts to obtain configuration data in the system registry. It
searches for the data under the key
<TT>HKEY_LOCAL_MACHINE\SOFTWARE\omniORB</TT>.</LI></UL><P>omniORB has a large number of parameters than can be configured. See
chapter&#XA0;<A HREF="#chap:config">4</A> for full details. The files
<TT>sample.cfg</TT> and <TT>sample.reg</TT> contain an example
configuration file and set of registry entries respectively.</P><P>To get all the omniORB examples running, the main thing you need to
configure is the Naming service, omniNames. To do that, the
configuration file or registry should contain an entry of the form</P><PRE CLASS="verbatim">  InitRef = NameService=corbaname::my.host.name
</PRE><P>See section&#XA0;<A HREF="#sec:corbaname">6.1.2</A> for full details of corbaname URIs.</P><!--TOC chapter The Basics-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc9">Chapter&#XA0;2</A>&#XA0;&#XA0;The Basics</H1><!--SEC END --><P>
<A NAME="chap:basics"></A></P><P>In this chapter, we go through three examples to illustrate the
practical steps to use omniORBpy. By going through the source code of
each example, the essential concepts and APIs are introduced. If you
have no previous experience with using CORBA, you should study this
chapter in detail. There are pointers to other essential documents you
should be familiar with.</P><P>If you have experience with using other ORBs, you should still go
through this chapter because it provides important information about
the features and APIs that are necessarily omniORB specific.</P><!--TOC section The Echo example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">2.1</A>&#XA0;&#XA0;The Echo example</H2><!--SEC END --><P>We use an example which is similar to the one used in the omniORB
manual. We define an interface, called <TT>Example::Echo</TT>, as
follows:</P><DIV CLASS="lstlisting"><I>// echo_example.idl</I>
<B>module</B> Example {
  <B>interface</B> Echo {
    <B>string</B> echoString(<B>in</B> <B>string</B> mesg);
  };
};</DIV><P>The important difference from the omniORB Echo example is that our
<TT>Echo</TT> interface is declared within an IDL module named
<TT>Example</TT>. The reason for this will become clear in a moment.</P><P>If you are new to IDL, you can learn about its syntax in Chapter 3 of
the CORBA specification 2.6&#XA0;[<A HREF="#corba26-spec">OMG01a</A>]. For the moment, you
only need to know that the interface consists of a single operation,
<TT>echoString()</TT>, which takes a string as an argument and returns a
copy of the same string.</P><P>The interface is written in a file, called <TT>example_echo.idl</TT>. It
is part of the CORBA standard that all IDL files should have the
extension &#X2018;<TT>.idl</TT>&#X2019;, although omniORB does not enforce this.</P><!--TOC section Generating the Python stubs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">2.2</A>&#XA0;&#XA0;Generating the Python stubs</H2><!--SEC END --><P>
<A NAME="sec:generatingStubs"></A></P><P>From the IDL file, we use the IDL compiler, omniidl, to produce the
Python stubs for that IDL. The stubs contain Python declarations for
all the interfaces and types declared in the IDL, as required by the
Python mapping. It is possible to generate stubs dynamically at
run-time, as described in section&#XA0;<A HREF="#sec:importIDL">4.9</A>, but it is more
efficient to generate them statically.</P><P>To generate the stubs, we use a command line like</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bpython example_echo.idl</TT>
</BLOCKQUOTE><P>As required by the standard, that produces two Python
packages derived from the module name <TT>Example</TT>. Directory
<TT>Example</TT> contains the client-side definitions (and also the type
declarations if there were any); directory <TT>Example__POA</TT>
contains the server-side skeletons. This explains the difficulty with
declarations at IDL global scope; section&#XA0;<A HREF="#sec:globalIDL">2.7</A> explains
how to access global declarations.</P><P>If you look at the Python code in the two packages, you will see that
they are almost empty. They simply import the
<TT>example_echo_idl.py</TT> file, which is where both the client and
server side declarations actually live. This arrangement is so that
omniidl can easily extend the packages if other IDL files add
declarations to the same IDL modules.</P><!--TOC section Object References and Servants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc12">2.3</A>&#XA0;&#XA0;Object References and Servants</H2><!--SEC END --><P>We contact a CORBA object through an <I>object reference</I>. The
actual implementation of a CORBA object is termed a <I>servant</I>.</P><P>Object references and servants are quite separate entities, and it is
important not to confuse the two. Client code deals purely with object
references, so there can be no confusion; object implementation code
must deal with both object references and servants. You will get a
run-time error if you use a servant where an object reference is
expected, or vice-versa.</P><!--TOC section Example 1 &#X2014; Colocated client and servant-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc13">2.4</A>&#XA0;&#XA0;Example 1 &#X2014; Colocated client and servant</H2><!--SEC END --><P>
<A NAME="sec:eg1"></A></P><P>In the first example, both the client and servant are in the same
address space. The next sections show how the client and servant can
be split between different address spaces.</P><P>First, the code:</P><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <I>#!/usr/bin/env python</I>
<FONT SIZE=1>   2</FONT> 
<FONT SIZE=1>   3</FONT> <B>import</B> sys
<FONT SIZE=1>   4</FONT> <B>from</B> omniORB <B>import</B> CORBA, PortableServer
<FONT SIZE=1>   5</FONT> <B>import</B> Example, Example__POA
<FONT SIZE=1>   6</FONT> 
<FONT SIZE=1>   7</FONT> <B>class</B> Echo_i (Example__POA.Echo):
<FONT SIZE=1>   8</FONT>     <B>def</B> echoString(self, mesg):
<FONT SIZE=1>   9</FONT>         <B>print</B> "echoString() called with message:", mesg
<FONT SIZE=1>  10</FONT>         <B>return</B> mesg
<FONT SIZE=1>  11</FONT> 
<FONT SIZE=1>  12</FONT> orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)
<FONT SIZE=1>  13</FONT> poa = orb.resolve_initial_references("RootPOA")
<FONT SIZE=1>  14</FONT> 
<FONT SIZE=1>  15</FONT> ei = Echo_i()
<FONT SIZE=1>  16</FONT> eo = ei._this()
<FONT SIZE=1>  17</FONT> 
<FONT SIZE=1>  18</FONT> poaManager = poa._get_the_POAManager()
<FONT SIZE=1>  19</FONT> poaManager.activate()
<FONT SIZE=1>  20</FONT> 
<FONT SIZE=1>  21</FONT> message = "Hello"
<FONT SIZE=1>  22</FONT> result  = eo.echoString(message)
<FONT SIZE=1>  23</FONT> 
<FONT SIZE=1>  24</FONT> <B>print</B> "I said '%s'. The object said '%s'." % (message,result)</DIV><P>The example illustrates several important interactions among the ORB,
the POA, the servant, and the client. Here are the details:</P><!--TOC subsection Imports-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">2.4.1</A>&#XA0;&#XA0;Imports</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 3</B></DT><DD CLASS="dd-description"><BR>
Import the <TT>sys</TT> module to access <TT>sys.argv</TT>.</DD><DT CLASS="dt-description"><B>Line 4</B></DT><DD CLASS="dd-description"><BR>
Import omniORB&#X2019;s implementations of the <TT>CORBA</TT> and
<TT>PortableServer</TT> modules. The standard requires that these
modules are available outside of any package, so you can also do<DIV CLASS="lstlisting"><B>import</B> CORBA, PortableServer</DIV><P>Explicitly specifying omniORB is useful if you have more
than one Python ORB installed.</P></DD><DT CLASS="dt-description"><B>Line 5</B></DT><DD CLASS="dd-description"><BR>
Import the client-side stubs and server-side skeletons generated for
IDL module <TT>Example</TT>.</DD></DL><!--TOC subsection Servant class definition-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">2.4.2</A>&#XA0;&#XA0;Servant class definition</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Lines 7&#X2013;10</B></DT><DD CLASS="dd-description"><BR>
For interface <TT>Example::Echo</TT>, omniidl produces a skeleton class
named <TT>Example__POA.Echo</TT>. Here we define an implementation
class, <TT>Echo_i</TT>, which derives from the skeleton class.<P>There is little constraint on how you design your implementation
class, except that it has to inherit from the skeleton class and must
implement all of the operations declared in the IDL. Note that since
Python is a dynamic language, errors due to missing operations and
operations with incorrect type signatures are only reported when
someone tries to call those operations.</P></DD></DL><!--TOC subsection ORB initialisation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">2.4.3</A>&#XA0;&#XA0;ORB initialisation</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 12</B></DT><DD CLASS="dd-description"><BR>
The ORB is initialised by calling the <TT>CORBA.ORB_init()</TT> function.
<TT>ORB_init()</TT> is passed a list of command-line arguments, and
an ORB identifier. The ORB identifier should be &#X2018;omniORB4&#X2019;, but it is
usually best to use <TT>CORBA.ORB_ID</TT>, which is initialised to a
suitable string, or leave it out altogether, and rely on the default.<P><TT>ORB_init()</TT> processes any command-line arguments which begin with
the string &#X2018;<TT>-ORB</TT>&#X2019;, and removes them from the argument
list. See section&#XA0;<A HREF="#sec:ORBargs">4.1.1</A> for details. If any arguments are
invalid, or other initialisation errors occur (such as errors in the
configuration file), the <TT>CORBA.INITIALIZE</TT> exception is raised.</P></DD></DL><!--TOC subsection Obtaining the Root POA-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">2.4.4</A>&#XA0;&#XA0;Obtaining the Root POA</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 13</B></DT><DD CLASS="dd-description"><BR>
To activate our servant object and make it available to clients, we
must register it with a POA. In this example, we use the <I>Root
POA</I>, rather than creating any child POAs. The Root POA is found with
<TT>orb.resolve_initial_references()</TT>.<P>A POA&#X2019;s behaviour is governed by its <I>policies</I>. The Root POA has
suitable policies for many simple servers. Chapter 11 of the CORBA 2.6
specification [<A HREF="#corba26-spec">OMG01a</A>] has details of all the POA policies
which are available.</P></DD></DL><!--TOC subsection Object initialisation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">2.4.5</A>&#XA0;&#XA0;Object initialisation</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 15</B></DT><DD CLASS="dd-description"><BR>
An instance of the Echo servant object is created.</DD><DT CLASS="dt-description"><B>Line 16</B></DT><DD CLASS="dd-description"><BR>
The object is implicitly activated in the Root POA, and an object
reference is returned, using the <TT>_this()</TT> method.<P>One of the important characteristics of an object reference is that it
is completely location transparent. A client can invoke on the object
using its object reference without any need to know whether the
servant object is colocated in the same address space or is in a
different address space.</P><P>In the case of colocated client and servant, omniORB is able to
short-circuit the client calls so they do not involve IIOP. The calls
still go through the POA, however, so the various POA policies affect
local calls in the same way as remote ones. This optimisation is
applicable not only to object references returned by <TT>_this()</TT>, but
to any object references that are passed around within the same
address space or received from other address spaces via IIOP calls.</P></DD></DL><!--TOC subsection Activating the POA-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">2.4.6</A>&#XA0;&#XA0;Activating the POA</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Lines 18&#X2013;19</B></DT><DD CLASS="dd-description"><BR>
POAs are initially in the <I>holding</I> state, meaning that incoming
requests are blocked. Lines 18 and 19 acquire a reference to the POA&#X2019;s
POA manager, and use it to put the POA into the <I>active</I> state.
Incoming requests are now served. <B>Failing to activate the POA
is one of the most common programming mistakes. If your program
appears deadlocked, make sure you activated the POA!</B></DD></DL><!--TOC subsection Performing a call-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">2.4.7</A>&#XA0;&#XA0;Performing a call</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 22</B></DT><DD CLASS="dd-description"><BR>
At long last, we can call the object&#X2019;s <TT>echoString()</TT> operation.
Even though the object is local, the operation goes through the ORB
and POA, so the types of the arguments can be checked, and any mutable
arguments can be copied. This ensures that the semantics of local and
remote calls are identical. If any of the arguments (or return values)
are of the wrong type, a <TT>CORBA.BAD_PARAM</TT> exception is raised.</DD></DL><!--TOC section Example 2 &#X2014; Different Address Spaces-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">2.5</A>&#XA0;&#XA0;Example 2 &#X2014; Different Address Spaces</H2><!--SEC END --><P>In this example, the client and the object implementation reside in
two different address spaces. The code of this example is almost the
same as the previous example. The only difference is the extra work
which needs to be done to pass the object reference from the object
implementation to the client.</P><P>The simplest (and quite primitive) way to pass an object reference
between two address spaces is to produce a <I>stringified</I> version
of the object reference and to pass this string to the client as a
command-line argument. The string is then converted by the client
into a proper object reference. This method is used in this
example. In the next example, we shall introduce a better way of
passing the object reference using the CORBA Naming Service.</P><!--TOC subsection Object Implementation: Making a Stringified Object Reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">2.5.1</A>&#XA0;&#XA0;Object Implementation: Making a Stringified Object Reference</H3><!--SEC END --><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <I>#!/usr/bin/env python</I>
<FONT SIZE=1>   2</FONT> 
<FONT SIZE=1>   3</FONT> <B>import</B> sys
<FONT SIZE=1>   4</FONT> <B>from</B> omniORB <B>import</B> CORBA, PortableServer
<FONT SIZE=1>   5</FONT> <B>import</B> Example, Example__POA
<FONT SIZE=1>   6</FONT> 
<FONT SIZE=1>   7</FONT> <B>class</B> Echo_i (Example__POA.Echo):
<FONT SIZE=1>   8</FONT>     <B>def</B> echoString(self, mesg):
<FONT SIZE=1>   9</FONT>         <B>print</B> "echoString() called with message:", mesg
<FONT SIZE=1>  10</FONT>         <B>return</B> mesg
<FONT SIZE=1>  11</FONT> 
<FONT SIZE=1>  12</FONT> orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)
<FONT SIZE=1>  13</FONT> poa = orb.resolve_initial_references("RootPOA")
<FONT SIZE=1>  14</FONT> 
<FONT SIZE=1>  15</FONT> ei = Echo_i()
<FONT SIZE=1>  16</FONT> eo = ei._this()
<FONT SIZE=1>  17</FONT> 
<FONT SIZE=1>  18</FONT> <B>print</B> orb.object_to_string(eo)
<FONT SIZE=1>  19</FONT> 
<FONT SIZE=1>  20</FONT> poaManager = poa._get_the_POAManager()
<FONT SIZE=1>  21</FONT> poaManager.activate()
<FONT SIZE=1>  22</FONT> 
<FONT SIZE=1>  23</FONT> orb.run()</DIV><P>Up until line 18, this example is identical to the colocated case. On
line 18, the ORB&#X2019;s <TT>object_to_string()</TT> operation is called. This
results in a string starting with the signature &#X2018;IOR:&#X2019; and followed by
some hexadecimal digits. All CORBA 2 compliant ORBs are able to
convert the string into its internal representation of a so-called
Interoperable Object Reference (IOR). The IOR contains the location
information and a key to uniquely identify the object implementation
in its own address space<SUP><A NAME="text1" HREF="#note1">1</A></SUP>. From the IOR, an object
reference can be constructed.</P><P>After the POA has been activated, <TT>orb.run()</TT> is called. Since
omniORB is fully multi-threaded, it is not actually necessary to call
<TT>orb.run()</TT> for operation dispatch to happen&#X2014;if the main program
had some other work to do, it could do so, and remote invocations
would be dispatched in separate threads. However, in the absence of
anything else to do, <TT>orb.run()</TT> is called so the thread blocks
rather than exiting immediately when the end-of-file is reached.
<TT>orb.run()</TT> stays blocked until the ORB is shut down.</P><!--TOC subsection Client: Using a Stringified Object Reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">2.5.2</A>&#XA0;&#XA0;Client: Using a Stringified Object Reference</H3><!--SEC END --><P>
<A NAME="clnt2"></A></P><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <I>#!/usr/bin/env python</I>
<FONT SIZE=1>   2</FONT> 
<FONT SIZE=1>   3</FONT> <B>import</B> sys
<FONT SIZE=1>   4</FONT> <B>from</B> omniORB <B>import</B> CORBA
<FONT SIZE=1>   5</FONT> <B>import</B> Example
<FONT SIZE=1>   6</FONT> 
<FONT SIZE=1>   7</FONT> orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)
<FONT SIZE=1>   8</FONT> 
<FONT SIZE=1>   9</FONT> ior = sys.argv[1]
<FONT SIZE=1>  10</FONT> obj = orb.string_to_object(ior)
<FONT SIZE=1>  11</FONT> 
<FONT SIZE=1>  12</FONT> eo = obj._narrow(Example.Echo)
<FONT SIZE=1>  13</FONT> 
<FONT SIZE=1>  14</FONT> <B>if</B> eo <B>is</B> None:
<FONT SIZE=1>  15</FONT>     <B>print</B> "Object reference is not an Example::Echo"
<FONT SIZE=1>  16</FONT>     sys.exit(1)
<FONT SIZE=1>  17</FONT> 
<FONT SIZE=1>  18</FONT> message = "Hello from Python"
<FONT SIZE=1>  19</FONT> result  = eo.echoString(message)
<FONT SIZE=1>  20</FONT> 
<FONT SIZE=1>  21</FONT> <B>print</B> "I said '%s'. The object said '%s'." % (message,result)</DIV><P>The stringified object reference is passed to the client as a
command-line argument<SUP><A NAME="text2" HREF="#note2">2</A></SUP>. The client uses the ORB&#X2019;s
<TT>string_to_object()</TT> function to convert the string into a generic
object reference (<TT>CORBA.Object</TT>).</P><P>On line 12, the object&#X2019;s <TT>_narrow()</TT> function is called to convert
the <TT>CORBA.Object</TT> reference into an <TT>Example.Echo</TT>
reference. If the IOR was not actually of type <TT>Example.Echo</TT>, or
something derived from it, <TT>_narrow()</TT> returns <TT>None</TT>.</P><P>In fact, since Python is a dynamically-typed language,
<TT>string_to_object()</TT> is often able to return an object reference of
a more derived type than <TT>CORBA.Object</TT>. See
section&#XA0;<A HREF="#sec:narrowing">3.1</A> for details.</P><!--TOC subsection System exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">2.5.3</A>&#XA0;&#XA0;System exceptions</H3><!--SEC END --><P>The keep it short, the client code shown above performs no exception
handling. A robust client (and server) should do, since there are a
number of system exceptions which can arise.</P><P>As already mentioned, <TT>ORB_init()</TT> can raise the
<TT>CORBA.INITIALIZE</TT> exception if the command line arguments or
configuration file are invalid. <TT>string_to_object()</TT> can
raise two exceptions: if the string is not an IOR (or a valid URI with
omniORB 3), it raises <TT>CORBA.BAD_PARAM</TT>; if the string looks
like an IOR, but contains invalid data, is raises
<TT>CORBA.MARSHAL</TT>.</P><P>The call to <TT>echoString()</TT> can result in any of the CORBA system
exceptions, since any exceptions not caught on the server side are
propagated back to the client. Even if the implementation of
<TT>echoString()</TT> does not raise any system exceptions itself, failures
in invoking the operation can cause a number of exceptions. First, if
the server process cannot be contacted, a <TT>CORBA.TRANSIENT</TT>
exception is raised. Second, if the server process <EM>can</EM> be
contacted, but the object in question does not exist there, a
<TT>CORBA.OBJECT_NOT_EXIST</TT> exception is raised.</P><P>As explained later in section&#XA0;<A HREF="#sec:narrowing">3.1</A>, the call to
<TT>_narrow()</TT> may also involve a call to the object to confirm its
type. This means that <TT>_narrow()</TT> can also raise
<TT>CORBA.TRANSIENT</TT>, <TT>CORBA.OBJECT_NOT_EXIST</TT>, and
<TT>CORBA.COMM_FAILURE</TT>.</P><P>Section&#XA0;<A HREF="#sec:exHandlers">4.7</A> describes how exception handlers can be
installed for all the various system exceptions, to avoid surrounding
all code with <TT>try</TT>&#X2026;<TT>except</TT> blocks.</P><!--TOC subsection Lifetime of a CORBA object-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">2.5.4</A>&#XA0;&#XA0;Lifetime of a CORBA object</H3><!--SEC END --><P>CORBA objects are either <I>transient</I> or <I>persistent</I>. The
majority are transient, meaning that the lifetime of the CORBA object
(as contacted through an object reference) is the same as the lifetime
of its servant object. Persistent objects can live beyond the
destruction of their servant object, the POA they were created in, and
even their process. Persistent objects are, of course, only
contactable when their associated servants are active, or can be
activated by their POA with a servant manager<SUP><A NAME="text3" HREF="#note3">3</A></SUP>. A reference to
a persistent object can be published, and will remain valid even if
the server process is restarted.</P><P>A POA&#X2019;s Lifespan Policy determines whether objects created within it
are transient or persistent. The Root POA has the <TT>TRANSIENT</TT>
policy.</P><P>An alternative to creating persistent objects is to register object
references in a <I>naming service</I> and bind them to fixed
pathnames. Clients can bind to the object implementations at runtime
by asking the naming service to resolve the pathnames to the object
references. CORBA defines a standard naming service, which is a
component of the Common Object Services (COS)&#XA0;[<A HREF="#corbaservices">OMG98</A>],
that can be used for this purpose. The next section describes an
example of how to use the COS Naming Service.</P><!--TOC section Example 3 &#X2014; Using the Naming Service-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">2.6</A>&#XA0;&#XA0;Example 3 &#X2014; Using the Naming Service</H2><!--SEC END --><P>
<A NAME="sec:usingNS"></A></P><P>In this example, the object implementation uses the Naming
Service&#XA0;[<A HREF="#corbaservices">OMG98</A>] to pass on the object reference to the
client. This method is far more practical than using stringified
object references. The full listings of the server and client are
below.</P><P>The names used by the Naming service consist of a sequence of
<I>name components</I>. Each name component has an <I>id</I> and a
<I>kind</I> field, both of which are strings. All name components
except the last one are bound to <I>naming contexts</I>. A naming
context is analogous to a directory in a filing system: it can contain
names of object references or other naming contexts. The last name
component is bound to an object reference.</P><P>Sequences of name components can be represented as a flat string,
using &#X2018;.&#X2019; to separate the id and kind fields, and &#X2018;/&#X2019; to separate name
components from each other<SUP><A NAME="text4" HREF="#note4">4</A></SUP>. In our example, the Echo object
reference is bound to the stringified name
&#X2018;<TT>test.my_context/ExampleEcho.Object</TT>&#X2019;.</P><P>The kind field is intended to describe the name in a
syntax-independent way. The naming service does not interpret, assign,
or manage these values. However, both the name and the kind attribute
must match for a name lookup to succeed. In this example, the kind
values for <TT>test</TT> and <TT>ExampleEcho</TT> are chosen to be
&#X2018;<TT>my_context</TT>&#X2019; and &#X2018;<TT>Object</TT>&#X2019; respectively. This is an
arbitrary choice as there is no standardised set of kind values.</P><!--TOC subsection Obtaining the Root Context object reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">2.6.1</A>&#XA0;&#XA0;Obtaining the Root Context object reference</H3><!--SEC END --><P>
<A NAME="resolveinit"></A></P><P>The initial contact with the Naming Service can be established via the
<I>root</I> context. The object reference to the root context is
provided by the ORB and can be obtained by calling
<TT>resolve_initial_references()</TT>. The following code fragment shows
how it is used:</P><DIV CLASS="lstlisting"><B>import</B> CosNaming
orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)
obj = orb.resolve_initial_references("NameService");
cxt = obj._narrow(CosNaming.NamingContext)</DIV><P>Remember, omniORB constructs its internal list of initial references
at initialisation time using the information provided in the
configuration file <TT>omniORB.cfg</TT>, or given on the command
line. If this file is not present, the internal list will be empty and
<TT>resolve_initial_references()</TT> will raise a
<TT>CORBA.ORB.InvalidName</TT> exception.</P><P>Note that, like <TT>string_to_object()</TT>,
<TT>resolve_initial_references()</TT> returns base <TT>CORBA.Object</TT>, so
we should narrow it to the interface we want. In this case, we want
<TT>CosNaming.NamingContext</TT><SUP><A NAME="text5" HREF="#note5">5</A></SUP>.</P><!--TOC subsection The Naming Service interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">2.6.2</A>&#XA0;&#XA0;The Naming Service interface</H3><!--SEC END --><P>It is beyond the scope of this chapter to describe in detail the
Naming Service interface. You should consult the CORBA services
specification&#XA0;[<A HREF="#corbaservices">OMG98</A>] (chapter 3).</P><!--TOC subsection Server code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">2.6.3</A>&#XA0;&#XA0;Server code</H3><!--SEC END --><P>Hopefully, the server code is self-explanatory:</P><DIV CLASS="lstlisting"><I>#!/usr/bin/env python</I>
<B>import</B> sys
<B>from</B> omniORB <B>import</B> CORBA, PortableServer
<B>import</B> CosNaming, Example, Example__POA

<I># Define an implementation of the Echo interface</I>
<B>class</B> Echo_i (Example__POA.Echo):
    <B>def</B> echoString(self, mesg):
        <B>print</B> "echoString() called with message:", mesg
        <B>return</B> mesg

<I># Initialise the ORB and find the root POA</I>
orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)
poa = orb.resolve_initial_references("RootPOA")

<I># Create an instance of Echo_i and an Echo object reference</I>
ei = Echo_i()
eo = ei._this()

<I># Obtain a reference to the root naming context</I>
obj         = orb.resolve_initial_references("NameService")
rootContext = obj._narrow(CosNaming.NamingContext)

<B>if</B> rootContext <B>is</B> None:
    <B>print</B> "Failed to narrow the root naming context"
    sys.exit(1)

<I># Bind a context named "test.my_context" to the root context</I>
name = [CosNaming.NameComponent("test", "my_context")]
<B>try</B>:
    testContext = rootContext.bind_new_context(name)
    <B>print</B> "New test context bound"

<B>except</B> CosNaming.NamingContext.AlreadyBound, ex:
    <B>print</B> "Test context already exists"
    obj = rootContext.resolve(name)
    testContext = obj._narrow(CosNaming.NamingContext)
    <B>if</B> testContext <B>is</B> None:
        <B>print</B> "test.mycontext exists but is not a NamingContext"
        sys.exit(1)

<I># Bind the Echo object to the test context</I>
name = [CosNaming.NameComponent("ExampleEcho", "Object")]
<B>try</B>:
    testContext.bind(name, eo)
    <B>print</B> "New ExampleEcho object bound"

<B>except</B> CosNaming.NamingContext.AlreadyBound:
    testContext.rebind(name, eo)
    <B>print</B> "ExampleEcho binding already existed -- rebound"

<I># Activate the POA</I>
poaManager = poa._get_the_POAManager()
poaManager.activate()

<I># Block for ever (or until the ORB is shut down)</I>
orb.run()</DIV><!--TOC subsection Client code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">2.6.4</A>&#XA0;&#XA0;Client code</H3><!--SEC END --><P>Hopefully the client code is self-explanatory too:</P><DIV CLASS="lstlisting"><I>#!/usr/bin/env python</I>
<B>import</B> sys
<B>from</B> omniORB <B>import</B> CORBA
<B>import</B> CosNaming, Example

<I># Initialise the ORB</I>
orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)

<I># Obtain a reference to the root naming context</I>
obj         = orb.resolve_initial_references("NameService")
rootContext = obj._narrow(CosNaming.NamingContext)

<B>if</B> rootContext <B>is</B> None:
    <B>print</B> "Failed to narrow the root naming context"
    sys.exit(1)

<I># Resolve the name "test.my_context/ExampleEcho.Object"</I>
name = [CosNaming.NameComponent("test", "my_context"),
        CosNaming.NameComponent("ExampleEcho", "Object")]
<B>try</B>:
    obj = rootContext.resolve(name)

<B>except</B> CosNaming.NamingContext.NotFound, ex:
    <B>print</B> "Name not found"
    sys.exit(1)

<I># Narrow the object to an Example::Echo</I>
eo = obj._narrow(Example.Echo)

<B>if</B> eo <B>is</B> None:
    <B>print</B> "Object reference is not an Example::Echo"
    sys.exit(1)

<I># Invoke the echoString operation</I>
message = "Hello from Python"
result  = eo.echoString(message)

<B>print</B> "I said '%s'. The object said '%s'." % (message,result)</DIV><!--TOC section Global IDL definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">2.7</A>&#XA0;&#XA0;Global IDL definitions</H2><!--SEC END --><P>
<A NAME="sec:globalIDL"></A></P><P>As we have seen, the Python mapping maps IDL modules to Python
packages with the same name. This poses a problem for IDL declarations
at global scope. Global declarations are generally a bad idea since
they make name clashes more likely, but they must be supported.</P><P>Since Python does not have a concept of a global scope (only a
per-module global scope, which is dangerous to modify), global
declarations are mapped to a specially named Python package. By
default, this package is named <TT>_GlobalIDL</TT>, with skeletons in
<TT>_GlobalIDL__POA</TT>. The package name may be changed with
omniidl&#X2019;s <TT>-Wbglobal</TT> option, described in
section&#XA0;<A HREF="#sec:Wbglobal">5.2</A>. The omniORB C++ Echo example, with IDL:</P><DIV CLASS="lstlisting"><B>interface</B> Echo {
  <B>string</B> echoString(<B>in</B> <B>string</B> mesg);
};</DIV><P>can therefore be supported with code like</P><DIV CLASS="lstlisting"><I>#!/usr/bin/env python</I>

<B>import</B> sys
<B>from</B> omniORB <B>import</B> CORBA
<B>import</B> _GlobalIDL

orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)

ior = sys.argv[1]
obj = orb.string_to_object(ior)
eo  = obj._narrow(_GlobalIDL.Echo)

message = "Hello from Python"
result  = eo.echoString(message)
<B>print</B> "I said '%s'. The object said '%s'" % (message,result)</DIV><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Notice that the object key is not
globally unique across address spaces.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">The code does not check that there is
actually an IOR on the command line!
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">3</A></DT><DD CLASS="dd-thefootnotes">The POA itself
can be activated on demand with an adapter activator.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">4</A></DT><DD CLASS="dd-thefootnotes">There are escaping rules to cope
with id and kind fields which contain &#X2018;.&#X2019; and &#X2018;/&#X2019; characters. See
chapter&#XA0;<A HREF="#chap:ins">6</A> of this manual, and chapter 3 of the CORBA
services specification, as updated for the Interoperable Naming
Service&#XA0;[<A HREF="#inschapters">OMG00</A>].
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">5</A></DT><DD CLASS="dd-thefootnotes">If you are on-the-ball, you
will have noticed that we didn&#X2019;t call <TT>_narrow()</TT> when resolving the
Root POA. The reason it is safe to miss it out is given in
section&#XA0;<A HREF="#sec:narrowing">3.1</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Python language mapping issues-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc32">Chapter&#XA0;3</A>&#XA0;&#XA0;Python language mapping issues</H1><!--SEC END --><P>omniORBpy adheres to the standard Python mapping&#XA0;[<A HREF="#pythonmapping">OMG01b</A>],
so there is no need to describe the mapping here. This chapter
outlines a number of issues which are not addressed by the standard
(or are optional), and how they are resolved in omniORBpy.</P><!--TOC section Narrowing object references-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">3.1</A>&#XA0;&#XA0;Narrowing object references</H2><!--SEC END --><P>
<A NAME="sec:narrowing"></A></P><P>As explained in chapter&#XA0;<A HREF="#chap:basics">2</A>, whenever you receive an
object reference declared to be base <TT>CORBA::Object</TT>, such as
from <TT>NamingContext::resolve()</TT> or
<TT>ORB::string_to_object()</TT>, you should narrow the reference to
the type you require. You might think that since Python is a
dynamically typed language, narrowing should never be necessary.
Unfortunately, although omniORBpy often generates object references
with the right types, it cannot do so in all circumstances.</P><P>The rules which govern when narrowing is required are quite complex.
To be totally safe, you can <EM>always</EM> narrow object references to
the type you are expecting. The advantages of this approach are that
it is simple and that it is guaranteed to work with all Python ORBs.</P><P>The disadvantage with calling narrow for all received object
references is that much of the time it is guaranteed not to be
necessary. If you understand the situations in which narrowing
<EM>is</EM> necessary, you can avoid spurious narrowing.</P><!--TOC subsection The gory details-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">3.1.1</A>&#XA0;&#XA0;The gory details</H3><!--SEC END --><P>When object references are transmitted (or stored in stringified
IORs), they contain a single type identifier string, termed the
<I>repository id</I>. Normally, the repository id represents the most
derived interface of the object. However, it is also permitted to be
the empty string, or to refer to an interface higher up the
inheritance hierarchy. To give a concrete example, suppose there are
two IDL files:</P><DIV CLASS="lstlisting"><I>// a.idl</I>
<B>module</B> M1 {
  <B>interface</B> A {
    <B>void</B> opA();
  };
};</DIV><DIV CLASS="lstlisting"><I>// b.idl</I>
<B>#include</B> "a.idl"
<B>module</B> M2 {
  <B>interface</B> B : M1::A {
    <B>void</B> opB();
  };
};</DIV><P>A reference to an object with interface <TT>B</TT> will
normally contain the repository id &#X2018;<TT>IDL:M2/B:1.0</TT>&#X2019;<SUP><A NAME="text6" HREF="#note6">1</A></SUP>. It is also permitted to have an empty
repository id, or the id &#X2018;<TT>IDL:M1/A:1.0</TT>&#X2019;.
&#X2018;<TT>IDL:M1/A:1.0</TT>&#X2019; is unlikely unless the server is being
deliberately obtuse.</P><P>Whenever omniORBpy receives an object reference from
somewhere&#X2014;either as a return value or as an operation argument&#X2014;it
has a particular <I>target</I> interface in mind, which it compares
with the repository id it has received. A target of base
<TT>CORBA::Object</TT> is just one (common) case. For example, in the
following IDL:</P><DIV CLASS="lstlisting"><I>// c.idl</I>
<B>#include</B> "a.idl"
<B>module</B> M3 {
  <B>interface</B> C {
    <B>Object</B> getObj();
    M1::A  getA();
  };
};</DIV><P>the target interface for <TT>getObj</TT>&#X2019;s return value is
<TT>CORBA::Object</TT>; the target interface for <TT>getA</TT>&#X2019;s return
value is <TT>M1::A</TT>.</P><P>omniORBpy uses the result of comparing the received and target
repository ids to determine the type of the object reference it
creates. The object reference has either the type of the received
reference, or the target type, according to this table:</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP COLSPAN=2><B>Case</B></TD><TD VALIGN=top ALIGN=left NOWRAP> <B>Objref Type</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
1.</TD><TD VALIGN=top ALIGN=left>The received id is the same as the target id</TD><TD VALIGN=top ALIGN=left NOWRAP>received</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
2.</TD><TD VALIGN=top ALIGN=left>The received id is not the same as the target id, but the
ORB knows that the received interface is derived from
the target interface</TD><TD VALIGN=top ALIGN=left NOWRAP>received</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
3.</TD><TD VALIGN=top ALIGN=left>The received id is unknown to the ORB</TD><TD VALIGN=top ALIGN=left NOWRAP>target</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
4.</TD><TD VALIGN=top ALIGN=left>The received id is not the same as the target id, and the
ORB knows that the received interface is <EM>not</EM>
derived from the target interface</TD><TD VALIGN=top ALIGN=left NOWRAP>target</TD></TR>
</TABLE>
</DIV><P>Cases 1 and 2 are the most common. Case 2 explains why it is not
necessary to narrow the result of calling
<TT>resolve_initial_references("RootPOA")</TT>: the return is always
of the known type <TT>PortableServer.POA</TT>, which is derived from the
target type of <TT>CORBA.Object</TT>.</P><P>Case 3 is also quite common. Suppose a client knows about IDL modules
<TT>M1</TT> and <TT>M3</TT> from above, but not module <TT>M2</TT>.
When it calls <TT>getA()</TT> on an instance of <TT>M3::C</TT>, the return
value may validly be of type <TT>M2::B</TT>, which it does not know. By
creating an object reference of type <TT>M1::A</TT> in this case, the
client is still able to call the object&#X2019;s <TT>opA()</TT> operation. On the
other hand, if <TT>getObj()</TT> returns an object of type <TT>M2::B</TT>, the
ORB will create a reference to base <TT>CORBA::Object</TT>, since that
is the target type.</P><P>Note that the ORB <EM>never</EM> rejects an object reference due to it
having the wrong type. Even if it knows that the received id is not
derived from the target interface (case 4), it might be the case that
the object actually has a more derived interface, which is derived
from both the type it is claiming to be <EM>and</EM> the target type.
That is, of course, extremely unlikely.</P><P>In cases 3 and 4, the ORB confirms the type of the object by calling
<TT>_is_a()</TT> just before the first invocation on the object. If it
turns out that the object is not of the right type after all, the
<TT>CORBA.INV_OBJREF</TT> exception is raised. The alternative to this
approach would be to check the types of object references when they
were received, rather than waiting until the first invocation. That
would be inefficient, however, since it is quite possible that a
received object reference will never be used. It may also cause
objects to be activated earlier than expected.</P><P>In summary, whenever your code receives an object reference, you
should bear in mind what omniORBpy&#X2019;s idea of the target type is. You
must not assume that the ORB will always correctly figure out a more
derived type than the target. One consequence of this is that you must
always narrow a plain <TT>CORBA::Object</TT> to a more specific type
before invoking on it<SUP><A NAME="text7" HREF="#note7">2</A></SUP>. You
<EM>can</EM> assume that the object reference you receive is of the
target type, or something derived from it, although the object it
refers to may turn out to be invalid. The fact that omniORBpy often
<EM>is</EM> able figure out a more derived type than the target is only
useful when using the Python interactive command line.</P><!--TOC section Support for Any values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">3.2</A>&#XA0;&#XA0;Support for Any values</H2><!--SEC END --><P>In statically typed languages, such as C++, Anys can only be used with
built-in types and IDL-declared types for which stubs have been
generated. If, for example, a C++ program receives an Any containing a
struct for which it does not have static knowledge, it cannot easily
extract the struct contents. The only solution is to use the
inconvenient DynAny interface.</P><P>Since Python is a dynamically typed language, it does not have this
difficulty. When omniORBpy receives an Any containing types it does
not know, it is able to create new Python types which behave exactly
as if there were statically generated stubs available. Note that this
behaviour is not required by the Python mapping specification, so
other Python ORBs may not be so accommodating.</P><P>The equivalent of DynAny creation can be achieved by dynamically
writing and importing new IDL, as described in
section&#XA0;<A HREF="#sec:importIDL">4.9</A>.</P><P>There is, however, a minor fly in the ointment when it comes to
receiving Anys. When an Any is transmitted, it is sent as a TypeCode
followed by the actual value. Normally, the TypeCodes for entities
with names&#X2014;members of structs, for example&#X2014;contain those names as
strings. That permits omniORBpy to create types with the corresponding
names. Unfortunately, the GIOP specification permits TypeCodes to be
sent with empty strings where the names would normally be. In this
situation, the types which omniORBpy creates cannot be given the
correct names. The contents of all types except structs and exceptions
can be accessed without having to know their names, through the
standard interfaces. Unknown structs, exceptions and valuetypes
received by omniORBpy have an attribute named &#X2018;<TT>_values</TT>&#X2019; which
contains a sequence of the member values. This attribute is omniORBpy
specific.</P><P>Similarly, TypeCodes for constructed types such as structs and unions
normally contain the repository ids of those types. This means that
omniORBpy can use types statically declared in the stubs when they are
available. Once again, the specification permits the repository id
strings to be empty<SUP><A NAME="text8" HREF="#note8">3</A></SUP>. This means that even if stubs for a type
received in an Any are available, it may not be able to create a
Python value with the right type. For example, with a struct
definition such as:</P><DIV CLASS="lstlisting"><B>module</B> M {
  <B>struct</B> S {
    <B>string</B> str;
    <B>long</B>   l;
  };
};</DIV><P>The transmitted TypeCode for <TT>M::S</TT> may contain only
the information that it is a structure containing a string followed by
a long, not that it is type <TT>M::S</TT>, or what the member names are.</P><P>To cope with this situation, omniORBpy has an extension to the
standard interface which allows you to <I>coerce</I> an Any value to a
known type. Calling an Any&#X2019;s <TT>value()</TT> method with a TypeCode
argument returns either a value of the requested type, or <TT>None</TT>
if the requested TypeCode is not <I>equivalent</I> to the Any&#X2019;s
TypeCode. The following code is guaranteed to be safe, but is not
standard:</P><DIV CLASS="lstlisting">a = <I># Acquire an Any from somewhere</I>
v = a.value(CORBA.TypeCode(CORBA.id(M.S)))
<B>if</B> v <B>is</B> <B>not</B> None:
    <B>print</B> v.str
<B>else</B>:
    <B>print</B> "The Any does not contain a value compatible with M::S."</DIV><!--TOC subsection Any helper module-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">3.2.1</A>&#XA0;&#XA0;Any helper module</H3><!--SEC END --><P>omniORBpy provides an alternative, non-standard way of constructing
and deconstructing Anys that is often more convenient to use in Python
programs. It uses Python&#X2019;s own dynamic typing to infer the TypeCodes
to use. The <TT>omniORB.any</TT> module contains two functions,
<TT>to_any()</TT> and <TT>from_any()</TT>.</P><P><TT>to_any()</TT> takes a Python object and tries to return it inside an
Any. It uses the following rules:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Python strings are represented as CORBA strings.
</LI><LI CLASS="li-itemize">Python unicode objects are represented as CORBA wstrings.
</LI><LI CLASS="li-itemize">Python integers are represented as CORBA longs.</LI><LI CLASS="li-itemize">Python long integers are represented as a CORBA integer type
taken from long, unsigned long, long long, unsigned long, depending on
what size type the Python long integer will fit in. If the value is
too large for any of these, <TT>CORBA.BAD_PARAM</TT> is raised.</LI><LI CLASS="li-itemize">Python lists and tuples of the types above are represented as
sequences of the corresponding CORBA types.</LI><LI CLASS="li-itemize">Python lists and tuples of mixed types are represented as
sequences of Anys.</LI><LI CLASS="li-itemize">Python dictionaries with string keys are represented as CORBA
structs, using the dictionary keys as the member names, and the
types of the dictionary values as the member types.</LI><LI CLASS="li-itemize">Instances of CORBA types (structs, unions, enums, etc.)
generated by the IDL compiler are represented as themselves.
</LI></UL><P>All other Python types result in a <TT>CORBA.BAD_PARAM</TT> exception.</P><P>The <TT>from_any()</TT> function works in reverse. It takes an Any as its
argument and extracts its contents using the same rules as
<TT>to_any()</TT>. By default, CORBA structs are extracted to dictionaries;
if the optional <TT>keep_structs</TT> argument is set true, they are
instead left as instances of the CORBA struct classes.</P><!--TOC section Interface Repository stubs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">3.3</A>&#XA0;&#XA0;Interface Repository stubs</H2><!--SEC END --><P>
<A NAME="sec:ifrstubs"></A></P><P>The Interface Repository interfaces are declared in IDL module
<TT>CORBA</TT> so, according to the Python mapping, the stubs for them
should appear in the Python <TT>CORBA</TT> module, along with all the
other CORBA definitions. However, since the stubs are extremely large,
omniORBpy does not include them by default. To do so would
unnecessarily increase the memory footprint and start-up time.</P><P>The Interface Repository stubs are automatically included if you
define the <TT>OMNIORBPY_IMPORT_IR_STUBS</TT> environment variable.
Alternatively, you can import the stubs at run-time by calling the
<TT>omniORB.importIRStubs()</TT> function. In both cases, the stubs become
available in the Python <TT>CORBA</TT> module.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note6" HREF="#text6">1</A></DT><DD CLASS="dd-thefootnotes">It
is possible to change the repository id strings associated with
particular interfaces using the <TT>ID</TT>, <TT>version</TT> and
<TT>prefix</TT> pragmas.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">2</A></DT><DD CLASS="dd-thefootnotes">Unless you are invoking pseudo
operations like <TT>_is_a()</TT> and <TT>_non_existent()</TT>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">3</A></DT><DD CLASS="dd-thefootnotes">The use of empty repository id strings is
deprecated as of GIOP 1.2.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter omniORB configuration and API-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc38">Chapter&#XA0;4</A>&#XA0;&#XA0;omniORB configuration and API</H1><!--SEC END --><P>
<A NAME="chap:config"></A></P><P>omniORB 4.1, and thus omniORBpy 3, has a wide range of parameters that
can be configured. They can be set in the configuration file / Windows
registry, as environment variables, or on the command line. A few
parameters can be configured at run time. This chapter lists all the
configuration parameters, and how they are used.</P><!--TOC section Setting parameters-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">4.1</A>&#XA0;&#XA0;Setting parameters</H2><!--SEC END --><P>When <TT>CORBA::ORB_init()</TT> is called, the value for each configuration
parameter is searched for in the following order:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Command line arguments
</LI><LI CLASS="li-enumerate">Environment variables
</LI><LI CLASS="li-enumerate">Configuration file / Windows registry
</LI><LI CLASS="li-enumerate">Built-in defaults</LI></OL><!--TOC subsection Command line arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.1.1</A>&#XA0;&#XA0;Command line arguments</H3><!--SEC END --><P>
<A NAME="sec:ORBargs"></A></P><P>Command line arguments take the form
&#X2018;<TT>-ORB</TT><I>parameter</I>&#X2019;, and usually expect another
argument. An example is &#X2018;<TT>-ORBtraceLevel 10</TT>&#X2019;.</P><!--TOC subsection Environment variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">4.1.2</A>&#XA0;&#XA0;Environment variables</H3><!--SEC END --><P>Environment variables consist of the parameter name prefixed with
&#X2018;<TT>ORB</TT>&#X2019;. Using bash, for example</P><DIV CLASS="lstlisting">export ORBtraceLevel=10</DIV><!--TOC subsection Configuration file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">4.1.3</A>&#XA0;&#XA0;Configuration file</H3><!--SEC END --><P>The best way to understand the format of the configuration file is to
look at the <TT>sample.cfg</TT> file in the omniORB distribution. Each
parameter is set on a single line like</P><PRE CLASS="verbatim">traceLevel = 10
</PRE><P>Some parameters can have more than one value, in which case the
parameter name may be specified more than once, or you can leave it
out:</P><PRE CLASS="verbatim">InitRef = NameService=corbaname::host1.example.com
        = InterfaceRepository=corbaloc::host2.example.com:1234/IfR
</PRE><DIV CLASS="minipage"><HR SIZE=2><DL CLASS="list"><DT CLASS="dt-list">

</DT><DD CLASS="dd-list">
Note how command line arguments and environment variables prefix
parameter names with &#X2018;-ORB&#X2019; and &#X2018;ORB&#X2019; respectively, but the
configuration file does not use a prefix.
</DD></DL><HR SIZE=2></DIV><!--TOC subsection Windows registry-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">4.1.4</A>&#XA0;&#XA0;Windows registry</H3><!--SEC END --><P>On Windows, configuration parameters can be stored in the registry,
under the key <TT>HKEY_LOCAL_MACHINE\SOFTWARE\omniORB</TT>.</P><P>The file <TT>sample.reg</TT> shows the settings that can be made. It can
be edited and then imported into regedit.</P><!--TOC section Tracing options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">4.2</A>&#XA0;&#XA0;Tracing options</H2><!--SEC END --><P>The following options control debugging trace output.</P><P><TT>traceLevel</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>omniORB can output tracing and diagnostic messages to the standard
error stream. The following levels are defined:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
level 0</TD><TD VALIGN=top ALIGN=left>critical errors only</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 1</TD><TD VALIGN=top ALIGN=left>informational messages only</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 2</TD><TD VALIGN=top ALIGN=left>configuration information and warnings</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
level 5</TD><TD VALIGN=top ALIGN=left>notifications when server threads are
created and communication endpoints are shutdown</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
level 10</TD><TD VALIGN=top ALIGN=left>execution and exception traces</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 25</TD><TD VALIGN=top ALIGN=left>trace each send or receive of a giop message</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 30</TD><TD VALIGN=top ALIGN=left>dump up to 128 bytes of each giop message</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 40</TD><TD VALIGN=top ALIGN=left>dump complete contents of each giop message</TD></TR>
</TABLE><P>The trace level is cumulative, so at level 40, all trace
messages are output.</P><P><TT>traceExceptions</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If the <TT>traceExceptions</TT> parameter is set true, all system
exceptions are logged as they are thrown, along with details about
where the exception is thrown from. This parameter is enabled by
default if the traceLevel is set to 10 or more.</P><P><TT>traceInvocations</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If the <TT>traceInvocations</TT> parameter is set true, all local and
remote invocations are logged, in addition to any logging that may
have been selected with <TT>traceLevel</TT>.</P><P><TT>traceInvocationReturns</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If the <TT>traceInvocationReturns</TT> parameter is set true, a log
message is output as an operation invocation returns. In conjunction
with <TT>traceInvocations</TT> and <TT>traceTime</TT> (described below),
this provides a simple way of timing CORBA calls within your
application.</P><P><TT>traceThreadId</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If <TT>traceThreadId</TT> is set true, all trace messages are prefixed
with the id of the thread outputting the message. This can be handy
for tracking down race conditions, but it adds significant overhead to
the logging function so it is turned off by default.</P><P><TT>traceTime</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If <TT>traceTime</TT> is set true, all trace messages are prefixed with
the time. This is useful, but on some platforms it adds a very large
overhead, so it is turned off by default.</P><P><TT>traceFile</TT> &#XA0;&#XA0; <I>default</I> =
</P><P>omniORB&#X2019;s tracing is normally sent to stderr. if <TT>traceFile</TT> it
set, the specified file name is used for trace messages.</P><!--TOC subsection Tracing API-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">4.2.1</A>&#XA0;&#XA0;Tracing API</H3><!--SEC END --><P>The tracing parameters can be inspected or modified at runtime with
the following functions in the <TT>omniORB</TT> module:</P><DIV CLASS="lstlisting">  traceLevel()
  traceExceptions()
  traceInvocations()
  traceInvocationReturns()
  traceThreadId()
  traceTime()</DIV><P>Calling one of the functions with no arguments returns the current
value; calling it with a single integer argument sets the value.</P><!--TOC section Miscellaneous global options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">4.3</A>&#XA0;&#XA0;Miscellaneous global options</H2><!--SEC END --><P>These options control miscellaneous features that affect the whole ORB
runtime.</P><P><TT>dumpConfiguration</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If set true, the ORB dumps the values of all configuration parameters
at start-up.</P><P><TT>scanGranularity</TT> &#XA0;&#XA0; <I>default</I> =
<TT>5</TT></P><P>As explained in chapter&#XA0;<A HREF="#chap:connections">7</A>, omniORB regularly
scans incoming and outgoing connections, so it can close unused
ones. This value is the granularity in seconds at which the ORB
performs its scans. A value of zero turns off the scanning altogether.</P><P><TT>nativeCharCodeSet</TT> &#XA0;&#XA0; <I>default</I> =
<TT>ISO-8859-1</TT></P><P>The native code set the application is using for <TT>char</TT> and
<TT>string</TT>. See chapter&#XA0;<A HREF="#chap:codesets">8</A>.</P><P><TT>nativeWCharCodeSet</TT> &#XA0;&#XA0; <I>default</I> =
<TT>UTF-16</TT></P><P>The native code set the application is using for <TT>wchar</TT> and
<TT>wstring</TT>. See chapter&#XA0;<A HREF="#chap:codesets">8</A>.</P><P><TT>copyValuesInLocalCalls</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>Determines whether valuetype parameters in local calls are copied or
not. See chapter&#XA0;<A HREF="#chap:valuetype">10</A>.</P><P><TT>abortOnInternalError</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If this is set true, internal fatal errors will abort immediately,
rather than throwing the <TT>omniORB::fatalException</TT> exception.
This can be helpful for tracking down bugs, since it leaves the call
stack intact.</P><P><TT>abortOnNativeException</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>On Windows, &#X2018;native&#X2019; exceptions such as segmentation faults and divide
by zero appear as C++ exceptions that can be caught with <TT>catch
(...)</TT>. Setting this parameter to true causes such exceptions to
abort the process instead.</P><P><TT>maxSocketSend</TT><BR>
<TT>maxSocketRecv</TT><BR>

On some platforms, calls to send() and recv() have a limit on the
buffer size that can be used. These parameters set the limits in bytes
that omniORB uses when sending / receiving bulk data.</P><P>The default values are platform specific. It is unlikely that you will
need to change the values from the defaults.</P><P>The minimum valid limit is 1KB, 1024 bytes.</P><P><TT>socketSendBuffer</TT> &#XA0;&#XA0; <I>default</I> =
<TT>-1 </TT><TT><I>or</I></TT><TT> 16384</TT></P><P>On Windows, there is a kernel buffer used during send operations. A
bug in Windows means that if a send uses the entire kernel buffer, a
select() on the socket blocks until all the data has been acknowledged
by the receiver, resulting in dreadful performance. This parameter
modifies the socket send buffer from its default (8192 bytes on
Windows) to the value specified. If this parameter is set to -1, the
socket send buffer is left at the system default.</P><P>On Windows, the default value of this parameter is 16384 bytes; on all
other platforms the default is -1.</P><P><TT>validateUTF8</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>When transmitting a string that is supposed to be UTF-8, omniORB
usually passes it directly, assuming that it is valid. With this
parameter set true, omniORB checks that all UTF-8 strings are valid,
and throws DATA_CONVERSION if not.</P><!--TOC section Client side options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc47">4.4</A>&#XA0;&#XA0;Client side options</H2><!--SEC END --><P>These options control aspects of client-side behaviour.</P><P><TT>InitRef</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>Specify objects available from
<TT>orb.resolve_initial_references()</TT>. The arguments take the form
&lt;<I>key</I>&gt;=&lt;<I>uri</I>&gt;, where the <I>key</I> is the name
given to <TT>resolve_initial_references()</TT> and
<I>uri</I> is a valid CORBA object reference URI, as detailed in
chapter&#XA0;<A HREF="#chap:ins">6</A>.</P><P><TT>DefaultInitRef</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>Specify the default URI prefix for
<TT>resolve_initial_references()</TT>, as explained in
chapter&#XA0;<A HREF="#chap:ins">6</A>.</P><P><TT>clientTransportRule</TT> &#XA0;&#XA0; <I>default</I> =
<TT>* unix,tcp,ssl</TT></P><P>Used to specify the way the client contacts a server, depending on the
server&#X2019;s address. See section&#XA0;<A HREF="#sec:clientRule">7.7.1</A> for details.</P><P><TT>clientCallTimeOutPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>Call timeout in milliseconds for the client side. If a call takes
longer than the specified number of milliseconds, the ORB closes the
connection to the server and raises a <TT>TRANSIENT</TT> exception. A
value of zero means no timeout; calls can block for ever. See
section&#XA0;<A HREF="#sec:timeoutAPI">7.3.1</A> for more information about timeouts.</P><P><B>Note</B>: omniORB 3 had timeouts specified in seconds;
omniORB 4.0 and later use milliseconds for timeouts.</P><P><TT>clientConnectTimeOutPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>The timeout that is used in the case that a new network connection is
established to the server. A value of zero means that the normal call
timeout is used. See section&#XA0;<A HREF="#sec:timeoutAPI">7.3.1</A> for more information
about timeouts.</P><P><TT>supportPerThreadTimeOut</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If this parameter is set true, timeouts can be set on a per thread
basis, as well as globally and per object. Checking per-thread storage
has a noticeable performance impact, so it is turned off by default.</P><P><TT>resetTimeoutOnRetries</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If true, the call timeout is reset when an exception handler causes a
call to be retried. If false, the timeout is not reset, and therefore
applies to the call as a whole, rather than to each individual call
attempt.</P><P><TT>outConScanPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>120</TT></P><P>Idle timeout in seconds for outgoing (i.e. client initiated)
connections. If a connection has been idle for this amount of time,
the ORB closes it. See section&#XA0;<A HREF="#sec:connShutdown">7.5</A>.</P><P><TT>maxGIOPConnectionPerServer</TT> &#XA0;&#XA0; <I>default</I> =
<TT>5</TT></P><P>The maximum number of concurrent connections the ORB will open to a
<EM>single</EM> server. If multiple threads on the client call the same
server, the ORB opens additional connections to the server, up to the
maximum specified by this parameter. If the maximum is reached,
threads are blocked until a connection becomes free for them to use.</P><P><TT>oneCallPerConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>When this parameter is set to true (the default), the ORB will only
send a single call on a connection at a time. If multiple client
threads invoke on the same server, multiple connections are opened, up
to the limit specified by
<TT>maxGIOPConnectionPerServer</TT>. With this parameter set to
false, the ORB will allow concurrent calls on a single
connection. This saves connection resources, but requires slightly
more management work for both client and server. Some server-side ORBs
(including omniORB versions before 4.0) serialise all calls on a
single connection.</P><P><TT>maxInterleavedCallsPerConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>5</TT></P><P>The maximum number of calls that can be interleaved on a connection.
If more concurrent calls are made, they are queued.</P><P><TT>offerBiDirectionalGIOP</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If set true, the client will indicate to servers that it is willing to
accept callbacks on client-initiated connections using bidirectional
GIOP, provided the relevant POA policies are set. See
section&#XA0;<A HREF="#sec:bidir">7.8</A>.</P><P><TT>verifyObjectExistsAndType</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>By default, omniORB uses the GIOP <TT>LOCATE_REQUEST</TT> message to
verify the existence of an object prior to the first invocation. In
the case that the full type of the object is not known, it instead
calls the <TT>_is_a()</TT> operation to check the object&#X2019;s type. Some ORBs
have bugs that mean one or other of these operations fail. Setting
this parameter false prevents omniORB from making these calls.</P><P><TT>giopTargetAddressMode</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>GIOP 1.2 supports three addressing modes for contacting objects. This
parameter selects the mode that omniORB uses. A value of 0 means
<TT>GIOP::KeyAddr</TT>; 1 means <TT>GIOP::ProfileAddr</TT>; 2 means
<TT>GIOP::ReferenceAddr</TT>.</P><P><TT>immediateAddressSwitch</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If true, the client will immediately switch to use a new address to
contact an object after a failure. If false (the default), the current
address will be retried in certain circumstances.</P><P><TT>bootstrapAgentHostname</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>If set, this parameter indicates the hostname to use for look-ups
using the obsolete Sun bootstrap agent. This mechanism is superseded
by the interoperable naming service.</P><P><TT>bootstrapAgentPort</TT> &#XA0;&#XA0; <I>default</I> =
<TT>900</TT></P><P>The port number for the obsolete Sun bootstrap agent.</P><P><TT>principal</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>GIOP 1.0 and 1.1 have a request header field named &#X2018;principal&#X2019;, which
contains a sequence of octets. It was never defined what it should
mean, and its use is now deprecated; GIOP 1.2 has no such field. Some
systems (e.g. Gnome) use the principal field as a primitive
authentication scheme. This parameter sets the data omniORB uses in
the principal field. The default is an empty sequence.</P><!--TOC section Server side options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc48">4.5</A>&#XA0;&#XA0;Server side options</H2><!--SEC END --><P>These parameters affect server-side operations.</P><P><TT>endPoint&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</TT> &#XA0;&#XA0; <I>default</I> = <TT>giop:tcp::</TT><BR>
<TT>endPointNoListen</TT><BR>
<TT>endPointPublish</TT><BR>
<TT>endPointNoPublish</TT><BR>
<TT>endPointPublishAllIFs</TT><BR>

These options determine the end-points the ORB should listen on, and
the details that should be published in IORs. See
chapter&#XA0;<A HREF="#chap:connections">7</A> for details.</P><P><TT>serverTransportRule</TT> &#XA0;&#XA0; <I>default</I> =
<TT>* unix,tcp,ssl</TT></P><P>Configure the rules about whether a server should accept an incoming
connection from a client. See section&#XA0;<A HREF="#sec:serverRule">7.7.2</A> for
details.</P><P><TT>serverCallTimeOutPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>This timeout is used to catch the situation that the server starts
receiving a request, but the end of the request never comes. If a
calls takes longer than the specified number of milliseconds to
arrive, the ORB shuts the connection. A value of zero means never
timeout.</P><P><TT>inConScanPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>180</TT></P><P>Idle timeout in seconds for incoming. If a connection has been idle
for this amount of time, the ORB closes it. See
section&#XA0;<A HREF="#sec:connShutdown">7.5</A>.</P><P><TT>threadPerConnectionPolicy</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>If true (the default), the ORB dedicates one server thread to each
incoming connection. Setting it false means the server should use a
thread pool.</P><P><TT>maxServerThreadPerConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>100</TT></P><P>If the client multiplexes several concurrent requests on a single
connection, omniORB uses extra threads to service them. This parameter
specifies the maximum number of threads that are allowed to service a
single connection at any one time.</P><P><TT>maxServerThreadPoolSize</TT> &#XA0;&#XA0; <I>default</I> =
<TT>100</TT></P><P>The maximum number of threads the server will allocate to do various
tasks, including dispatching calls in the thread pool mode. This
number does not include threads dispatched under the thread per
connection server mode.</P><P><TT>threadPerConnectionUpperLimit</TT> &#XA0;&#XA0; <I>default</I> =
<TT>10000</TT></P><P>If the <TT>threadPerConnectionPolicy</TT> parameter is true, the ORB can
automatically transition to thread pool mode if too many connections
arrive. This parameter sets the number of connections at which thread
pooling is started. The default of 10000 is designed to mean that it
never happens.</P><P><TT>threadPerConnectionLowerLimit</TT> &#XA0;&#XA0; <I>default</I> =
<TT>9000</TT></P><P>If thread pooling was started because the number of connections hit
the upper limit, this parameter determines when thread per connection
should start again.</P><P><TT>threadPoolWatchConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>After dispatching an upcall in thread pool mode, the thread that has
just performed the call can watch the connection for a short time
before returning to the pool. This leads to less thread switching for
a series of calls from a single client, but is less fair if there are
concurrent clients. The connection is watched if the number of threads
concurrently handling the connection is &lt;= the value of this
parameter. i.e. if the parameter is zero, the connection is never
watched; if it is 1, the last thread managing a connection watches it;
if 2, the connection is still watched if there is one other thread
still in an upcall for the connection, and so on.</P><P>See section&#XA0;<A HREF="#sec:watchConn">7.4.2</A>.</P><P><TT>connectionWatchPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>50000</TT></P><P>For each endpoint, the ORB allocates a thread to watch for new
connections and to monitor existing connections for calls that should
be handed by the thread pool. The thread blocks in select() or similar
for a period, after which it re-scans the lists of connections it
should watch. This parameter is specified in microseconds.</P><P><TT>connectionWatchImmediate</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>When a thread handles an incoming call, it unmarshals the arguments
then marks the connection as watchable by the connection watching
thread, in case the client sends a concurrent call on the same
connection. If this parameter is set to the default false, the
connection is not actually watched until the next connection watch
period (determined by the <TT>connectionWatchPeriod</TT> parameter). If
this parameter is set true, the connection watching thread is
immediately signalled to watch the connection. That leads to faster
interactive response to clients that multiplex calls, but adds
significant overhead along the call chain.</P><P>Note that this setting has no effect on Windows, since it has no
mechanism for signalling the connection watching thread.</P><P><TT>acceptBiDirectionalGIOP</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>Determines whether a server will ever accept clients&#X2019; offers of
bidirectional GIOP connections. See section&#XA0;<A HREF="#sec:bidir">7.8</A>.</P><P><TT>unixTransportDirectory</TT> &#XA0;&#XA0; <I>default</I> =
<TT>/tmp/omni-%u</TT></P><P>(Unix platforms only). Selects the location used to store Unix domain
sockets. The &#X2018;<TT>%u</TT>&#X2019; is expanded to the user name.</P><P><TT>unixTransportPermission</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0777</TT></P><P>(Unix platforms only). Determines the octal permission bits for Unix
domain sockets. By default, all users can connect to a server, just as
with TCP.</P><P><TT>supportCurrent</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>omniORB supports the <TT>PortableServer::Current</TT> interface to
provide thread context information to servants. Supporting current has
a small but noticeable run-time overhead due to accessing thread
specific storage, so this option allows it to be turned off.</P><P><TT>objectTableSize</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>Hash table size of the Active Object Map. If this is zero, the ORB
uses a dynamically resized open hash table. This is normally the best
option, but it leads to less predictable performance since any
operation which adds or removes a table entry may trigger a resize. If
set to a non-zero value, the hash table has the specified number of
entries, and is never resized. Note that the hash table is open, so
this does not limit the number of active objects, just how efficiently
they can be located.</P><P><TT>poaHoldRequestTimeout</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If a POA is put in the <TT>HOLDING</TT> state, calls to it will be timed
out after the specified number of milliseconds, by raising a
<TT>TRANSIENT</TT> exception. Zero means no timeout.</P><P><TT>poaUniquePersistentSystemIds</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>The POA specification requires that object ids in POAs with the
PERSISTENT and SYSTEM_ID policies are unique between instantiations
of the POA. Older versions of omniORB did not comply with that, and
reused object ids. With this value true, the POA has the correct
behaviour; with false, the POA uses the old scheme for compatibility.</P><P><TT>idleThreadTimeout</TT> &#XA0;&#XA0; <I>default</I> =
<TT>10</TT></P><P>When a thread created by omniORB becomes idle, it is kept alive for a
while, in case a new thread is required. Once a thread has been idle
for the number of seconds specified in this parameter, it exits.</P><P><TT>supportBootstrapAgent</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If set true, servers support the Sun bootstrap agent protocol.</P><!--TOC section GIOP and interoperability options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">4.6</A>&#XA0;&#XA0;GIOP and interoperability options</H2><!--SEC END --><P>These options control omniORB&#X2019;s use of GIOP, and cover some areas
where omniORB can work around buggy behaviour by other ORBs.</P><P><TT>maxGIOPVerson</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1.2</TT></P><P>Choose the maximum GIOP version the ORB should support. Valid values
are 1.0, 1.1 and 1.2.</P><P><TT>giopMaxMsgSize</TT> &#XA0;&#XA0; <I>default</I> =
<TT>2097152</TT></P><P>The largest message, in bytes, that the ORB will send or receive, to
avoid resource starvation. If the limit is exceeded, a <TT>MARSHAL</TT>
exception is thrown. The size must be &gt;= 8192.</P><P><TT>strictIIOP</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>If true, be strict about interpretation of the IIOP specification; if
false, permit some buggy behaviour to pass.</P><P><TT>lcdMode</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If true, select &#X2018;Lowest Common Denominator&#X2019; mode. This disables
various IIOP and GIOP features that are known to cause problems with
some ORBs.</P><P><TT>tcAliasExpand</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>This flag is used to indicate whether TypeCodes associated with Anys
should have aliases removed. This functionality is included because
some ORBs will not recognise an Any containing a TypeCode with aliases
to be the same as the actual type contained in the Any. Note that
omniORB will always remove top-level aliases, but will not remove
aliases from TypeCodes that are members of other TypeCodes (e.g.
TypeCodes for members of structs etc.), unless <TT>tcAliasExpand</TT> is
set to 1. There is a performance penalty when inserting into an Any if
<TT>tcAliasExpand</TT> is set to 1.</P><P><TT>useTypeCodeIndirections</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>TypeCode Indirections reduce the size of marshalled TypeCodes, and are
essential for recursive types, but some old ORBs do not support them.
Setting this flag to false prevents the use of indirections (and,
therefore, recursive TypeCodes).</P><P><TT>acceptMisalignedTcIndirections</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If true, try to fix a mis-aligned indirection in a typecode. This is
used to work around a bug in some old versions of Visibroker&#X2019;s Java
ORB.</P><!--TOC section System Exception Handlers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">4.7</A>&#XA0;&#XA0;System Exception Handlers</H2><!--SEC END --><P>
<A NAME="sec:exHandlers"></A></P><P>By default, all system exceptions that are raised during an operation
invocation, with the exception of some cases of
<TT>CORBA.TRANSIENT</TT>, are propagated to the application code. Some
applications may prefer to trap these exceptions within the proxy
objects so that the application logic does not have to deal with the
error condition. For example, when a <TT>CORBA.COMM_FAILURE</TT> is
received, an application may just want to retry the invocation until
it finally succeeds. This approach is useful for objects that are
persistent and have idempotent operations.</P><P>omniORBpy provides a set of functions to install exception handlers.
Once they are installed, proxy objects will call these handlers when
the associated system exceptions are raised by the ORB runtime.
Handlers can be installed for <TT>CORBA.TRANSIENT</TT>,
<TT>CORBA.COMM_FAILURE</TT> and <TT>CORBA.SystemException</TT>. This
last handler covers all system exceptions other than the two covered
by the first two handlers. An exception handler can be installed for
individual proxy objects, or it can be installed for all proxy objects
in the address space.</P><!--TOC subsection Minor codes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc51">4.7.1</A>&#XA0;&#XA0;Minor codes</H3><!--SEC END --><P>omniORB makes extensive use of exception minor codes to indicate the
specific circumstances surrounding a system exception. The C++ file
<TT>include/omniORB4/minorCode.h</TT> contains definitions of all the
minor codes used in omniORB, covering codes allocated in the CORBA
specification, and ones specific to omniORB.</P><P>Applications can use minor codes to adjust their behaviour according
to the condition. You can receive a string format of a minor code by
calling the <TT>omniORB.minorCodeToString()</TT> function, passing an
exception object as its argument.</P><!--TOC subsection CORBA::TRANSIENT handlers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">4.7.2</A>&#XA0;&#XA0;CORBA::TRANSIENT handlers</H3><!--SEC END --><P><TT>TRANSIENT</TT> exceptions can occur in many circumstances. One
circumstance is as follows:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">The client invokes on an object reference.
</LI><LI CLASS="li-enumerate">The object replies with a <TT>LOCATION_FORWARD</TT> message.
</LI><LI CLASS="li-enumerate">The client caches the new location and retries to the new location.
</LI><LI CLASS="li-enumerate">Time passes...
</LI><LI CLASS="li-enumerate">The client tries to invoke on the object again, using the
cached, forwarded location. 
</LI><LI CLASS="li-enumerate">The attempt to contact the object fails.
</LI><LI CLASS="li-enumerate">The ORB runtime resets the location cache and throws a
<TT>TRANSIENT</TT> exception with minor code
<TT>TRANSIENT_FailedOnForwarded</TT>.</LI></OL><P>In this situation, the default <TT>TRANSIENT</TT> exception handler
retries the call, using the object&#X2019;s original location. If the retry
results in another <TT>LOCATION_FORWARD</TT>, to the same or a
different location, and <EM>that</EM> forwarded location fails
immediately, the <TT>TRANSIENT</TT> exception will occur again, and the
pattern will repeat. With repeated exceptions, the handler starts
adding delays before retries, with exponential back-off.</P><P>In all other circumstances, the default <TT>TRANSIENT</TT> handler just
passes the exception on to the caller.</P><P>You can override the default behaviour by installing your own
exception handler. The function to call has signature:</P><DIV CLASS="lstlisting">omniORB.installTransientExceptionHandler(cookie, function [, object])</DIV><P>The arguments are a cookie, which is any Python object, a call-back
function, and optionally an object reference. If the object reference
is present, the exception handler is installed for just that object;
otherwise the handler is installed for all objects with no handler of
their own.</P><P>The call-back function must have the signature</P><DIV CLASS="lstlisting">function(cookie, retries, exc) -&gt; boolean</DIV><P>When a <TT>TRANSIENT</TT> exception occurs, the function is called,
passing the cookie object, a count of how many times the operation has
been retried, and the TRANSIENT exception object itself. If the
function returns true, the operation is retried; if it returns false,
the original exception is raised in the application. In the case of a
<TT>TRANSIENT</TT> exception due to a failed location forward, the
exception propagated to the application is the <EM>original</EM>
exception that caused the <TT>TRANSIENT</TT> (e.g. a
<TT>COMM_FAILURE</TT> or <TT>OBJECT_NOT_EXIST</TT>), rather than the
<TT>TRANSIENT</TT> exception<SUP><A NAME="text9" HREF="#note9">1</A></SUP>.</P><!--TOC subsection CORBA.COMM_FAILURE and CORBA.SystemException-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc53">4.7.3</A>&#XA0;&#XA0;CORBA.COMM_FAILURE and CORBA.SystemException</H3><!--SEC END --><P>There are two other functions for registering exception handlers: one
for <TT>CORBA.COMM_FAILURE</TT>, and one for all other
exceptions. For both these cases, the default is for there to be no
handler, so exceptions are propagated to the application.</P><DIV CLASS="lstlisting">omniORB.installCommFailureExceptionHandler(cookie, function [, object])
omniORB.installSystemExceptionHandler(cookie, function [, object])</DIV><P>In both cases, the call-back function has the same signature
as for <TT>TRANSIENT</TT> handlers.</P><!--TOC section Location forwarding-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc54">4.8</A>&#XA0;&#XA0;Location forwarding</H2><!--SEC END --><P>
<A NAME="sec:locationForward"></A></P><P>Any CORBA operation invocation can return a <TT>LOCATION_FORWARD</TT>
message to the caller, indicating that it should retry the invocation
on a new object reference. The standard allows ServantManagers to
trigger <TT>LOCATION_FORWARD</TT>s by raising the
<TT>PortableServer.ForwardRequest</TT> exception, but it does not
provide a similar mechanism for normal servants. omniORB provides the
<TT>omniORB.LOCATION_FORWARD</TT> exception for this purpose. It
can be thrown by any operation implementation.</P><!--TOC section Dynamic importing of IDL-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc55">4.9</A>&#XA0;&#XA0;Dynamic importing of IDL</H2><!--SEC END --><P>
<A NAME="sec:importIDL"></A></P><P>omniORBpy is usually used with pre-generated stubs. Since Python is a
dynamic language, however, it is possible to compile and import new
stubs at run-time.</P><P>Dynamic importing is achieved with <TT>omniORB.importIDL()</TT> and
<TT>omniORB.importIDLString()</TT>. Their signatures are:</P><DIV CLASS="lstlisting">importIDL(filename [, args ]) -&gt; tuple
importIDLString(string [, args ]) -&gt; tuple</DIV><P>The first function compiles and imports the specified file; the second
takes a string containing the IDL definitions. The functions work by
forking omniidl and importing its output<SUP><A NAME="text10" HREF="#note10">2</A></SUP>; they both take an optional
argument containing a list of strings which are used as arguments for
omniidl. For example, the following command runs omniidl with an
include path set:</P><DIV CLASS="lstlisting">m = omniORB.importIDL("test.idl", ["-I/my/include/path"])</DIV><P>Instead of specifying omniidl arguments on each import, you
can set the arguments to be used for all calls using the
<TT>omniORB.omniidlArguments()</TT> function.</P><P>Both import functions return a tuple containing the names of the
Python modules that have been imported. The modules themselves can be
accessed through <TT>sys.modules</TT>. For example:</P><DIV CLASS="lstlisting"><I>// test.idl</I>
<B>const</B> <B>string</B> s = "Hello";
<B>module</B> M1 {
  <B>module</B> M2 {
    <B>const</B> <B>long</B> l = 42;
  };
};
<B>module</B> M3 {
  <B>const</B> <B>short</B> s = 5;
};</DIV><P>From Python:</P><DIV CLASS="lstlisting">&gt;&gt;&gt; <B>import</B> sys, omniORB
&gt;&gt;&gt; omniORB.importIDL("test.idl")
('M1', 'M1.M2', 'M3', '_GlobalIDL')
&gt;&gt;&gt; sys.modules["M1.M2"].l
42
&gt;&gt;&gt; sys.modules["M3"].s
5
&gt;&gt;&gt; sys.modules["_GlobalIDL"].s
'Hello'</DIV><P>Note that each time <TT>importIDL()</TT> or <TT>importIDLString()</TT> is called,
the IDL definitions are compiled and imported into the associated
Python declarations. The new declarations overwrite any old ones with
the same names. This can cause confusing situations where different
modules see different definitions of the same objects. Although the
objects appear identical, they are not, and comparisons within
applications and within omniORBpy unexpectedly fail. You should not
use these functions in more than one module to import the same IDL
files.</P><!--TOC section C++ API-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc56">4.10</A>&#XA0;&#XA0;C++ API</H2><!--SEC END --><P>omniORBpy has a C++ API that can be used by programs that embed Python
in C++, or by C++ extension modules to Python. The API has functions
to convert object references between their Python representation and
their C++ representation. For extensions to omniORBpy itself, it has a
mechanism for adding pseudo object types to omniORBpy.</P><P>The definitions used by the C++ API are in the <TT>omniORBpy.h</TT>
header. An example of its use is in <TT>examples/embed/</TT>.</P><P>The API is accessed through a singleton structure containing function
pointers. A pointer to the API struct is stored as a <TT>PyCObject</TT>
in the <TT>_omnipy</TT> module with the name <TT>API</TT>. It can be
accessed with code like:</P><DIV CLASS="lstlisting">PyObject*     omnipy = PyImport_ImportModule((<B>char</B>*)"_omnipy");
PyObject*     pyapi  = PyObject_GetAttrString(omnipy, (<B>char</B>*)"API");
omniORBpyAPI* api    = (omniORBpyAPI*)PyCObject_AsVoidPtr(pyapi);
Py_DECREF(pyapi);</DIV><P>The structure has this definition:</P><DIV CLASS="lstlisting"><B>struct</B> omniORBpyAPI {

  PyObject* (*cxxObjRefToPyObjRef)(<B>const</B> CORBA::Object_ptr cxx_obj,
                                   CORBA::Boolean hold_lock);
  <I>// Convert a C++ object reference to a Python object reference.</I>
  <I>// If &lt;hold_lock&gt; is true, caller holds the Python interpreter lock.</I>

  CORBA::Object_ptr (*pyObjRefToCxxObjRef)(PyObject* py_obj,
                                           CORBA::Boolean hold_lock);
  <I>// Convert a Python object reference to a C++ object reference.</I>
  <I>// Raises BAD_PARAM if the Python object is not an object reference.</I>
  <I>// If &lt;hold_lock&gt; is true, caller holds the Python interpreter lock.</I>
};</DIV><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note9" HREF="#text9">1</A></DT><DD CLASS="dd-thefootnotes">This is a change from omniORB 4.0
/ omniORBpy 2 and earlier, where it was the <TT>TRANSIENT</TT> exception
that was propagated to the application.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">2</A></DT><DD CLASS="dd-thefootnotes">omniidl must
therefore be available on your path.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter The IDL compiler-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc57">Chapter&#XA0;5</A>&#XA0;&#XA0;The IDL compiler</H1><!--SEC END --><P>
<A NAME="chap:omniidl"></A></P><P>omniORBpy&#X2019;s IDL compiler is called omniidl. It consists of a generic
front-end parser written in C++, and a number of back-ends written in
Python. omniidl is very strict about IDL validity, so you may find
that it reports errors in IDL which compiles fine with other IDL
compilers.</P><P>The general form of an omniidl command line is:</P><BLOCKQUOTE CLASS="quote"> <TT>omniidl </TT>[<I>options</I>]<TT> -b</TT>&lt;<I>back-end</I>&gt;<TT> </TT>[<I>back-end options</I>]<TT> </TT>&lt;<I>file 1</I>&gt;<TT> </TT>&lt;<I>file 2</I>&gt;<TT> </TT>&#X2026;</BLOCKQUOTE><!--TOC section Common options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc58">5.1</A>&#XA0;&#XA0;Common options</H2><!--SEC END --><P>The following options are common to all back-ends:</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-b</TT><I>back-end</I></TD><TD ALIGN=left NOWRAP>Run the specified back-end. For omniORBpy, use <TT>-bpython</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-D</TT><I>name</I>[<TT>=</TT><I>value</I>]</TD><TD ALIGN=left NOWRAP>Define <I>name</I> for the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-U</TT><I>name</I></TD><TD ALIGN=left NOWRAP>Undefine <I>name</I> for the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-I</TT><I>dir</I></TD><TD ALIGN=left NOWRAP>Include <I>dir</I> in the preprocessor search path.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-E</TT></TD><TD ALIGN=left NOWRAP>Only run the preprocessor, sending its output to stdout.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Y</TT><I>cmd</I></TD><TD ALIGN=left NOWRAP>Use <I>cmd</I> as the preprocessor, rather than the normal C
preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-N</TT></TD><TD ALIGN=left NOWRAP>Do not run the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-T</TT></TD><TD ALIGN=left NOWRAP>Use a temporary file, not a pipe, for preprocessor output.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wp</TT><I>arg</I>[,<I>arg</I>&#X2026;]</TD><TD ALIGN=left NOWRAP>Send arguments to the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wb</TT><I>arg</I>[,<I>arg</I>&#X2026;]</TD><TD ALIGN=left NOWRAP>Send arguments to the back-end.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-nf</TT></TD><TD ALIGN=left NOWRAP>Do not warn about unresolved forward declarations.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-k</TT></TD><TD ALIGN=left NOWRAP>Keep comments after declarations, to be used by some back-ends.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-K</TT></TD><TD ALIGN=left NOWRAP>Keep comments before declarations, to be used by some back-ends.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-C</TT><I>dir</I></TD><TD ALIGN=left NOWRAP>Change directory to <I>dir</I> before writing output files.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-d</TT></TD><TD ALIGN=left NOWRAP>Dump the parsed IDL then exit, without running a back-end.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-p</TT><I>dir</I></TD><TD ALIGN=left NOWRAP>Use <I>dir</I> as a path to find omniidl back-ends.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-V</TT></TD><TD ALIGN=left NOWRAP>Print version information then exit.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-u</TT></TD><TD ALIGN=left NOWRAP>Print usage information.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-v</TT></TD><TD ALIGN=left NOWRAP>Verbose: trace compilation stages.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
</TD></TR>
</TABLE><P>Most of these options are self explanatory, but some are not
so obvious.</P><!--TOC subsection Preprocessor interactions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">5.1.1</A>&#XA0;&#XA0;Preprocessor interactions</H3><!--SEC END --><P>IDL is processed by the C preprocessor before omniidl parses it.
omniidl always uses the GNU C preprocessor (which it builds with the
name omnicpp). The <TT>-D</TT>, <TT>-U</TT>, and <TT>-I</TT>
options are just sent to the preprocessor. Note that the current
directory is not on the include search path by default&#X2014;use
&#X2018;<TT>-I.</TT>&#X2019; for that. The <TT>-Y</TT> option can be used to
specify a different preprocessor to omnicpp. Beware that line
directives inserted by other preprocessors are likely to confuse
omniidl.</P><!--TOC subsubsection Windows 9x-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc60">5.1.1.1</A>&#XA0;&#XA0;Windows 9x</H4><!--SEC END --><P>The output from the C preprocessor is normally fed to the omniidl
parser through a pipe. On some Windows 98 machines (but not all!) the
pipe does not work, and the preprocessor output is echoed to the
screen. When this happens, the omniidl parser sees an empty file, and
produces useless stub files with strange long names. To avoid the
problem, use the &#X2018;<TT>-T</TT>&#X2019; option to create a temporary file
between the two stages.</P><!--TOC subsection Forward-declared interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">5.1.2</A>&#XA0;&#XA0;Forward-declared interfaces</H3><!--SEC END --><P>If you have an IDL file like:</P><DIV CLASS="lstlisting"><B>interface</B> I;
<B>interface</B> J {
  <B>attribute</B> I the_I;
};</DIV><P>then omniidl will normally issue a warning:</P><PRE CLASS="verbatim">  test.idl:1: Warning: Forward declared interface `I' was never
  fully defined
</PRE><P>It is illegal to declare such IDL in isolation, but it
<EM>is</EM> valid to define interface <TT>I</TT> in a separate file. If
you have a lot of IDL with this sort of construct, you will drown
under the warning messages. Use the <TT>-nf</TT> option to suppress
them.</P><!--TOC subsection Comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc62">5.1.3</A>&#XA0;&#XA0;Comments</H3><!--SEC END --><P>By default, omniidl discards comments in the input IDL. However, with
the <TT>-k</TT> and <TT>-K</TT> options, it preserves the comments
for use by the back-ends. The Python back-end ignores this
information, but it is relatively easy to write new back-ends which
<EM>do</EM> make use of comments.</P><P>The two different options relate to how comments are attached to
declarations within the IDL. Given IDL like:</P><DIV CLASS="lstlisting"><B>interface</B> I {
  <B>void</B> op1();
  <I>// A comment</I>
  <B>void</B> op2();
};</DIV><P>the <TT>-k</TT> flag will attach the comment to <TT>op1()</TT>;
the <TT>-K</TT> flag will attach it to <TT>op2()</TT>.</P><!--TOC section Python back-end options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">5.2</A>&#XA0;&#XA0;Python back-end options</H2><!--SEC END --><P>
<A NAME="sec:Wbglobal"></A></P><P>When you specify the Python back-end (with <TT>-bpython</TT>), the
following <TT>-Wb</TT> options are available. Note that the
<TT>-Wb</TT> options must be specified <EM>after</EM> the
<TT>-bpython</TT> option, so omniidl knows which back-end to give the
arguments to.</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbstdout</TT></TD><TD ALIGN=left NOWRAP>Send the generated stubs to standard output, rather than to a
file.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbinline</TT></TD><TD ALIGN=left NOWRAP>Output stubs for #included files in line with the main
file.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbglobal=</TT><I>g</I></TD><TD ALIGN=left NOWRAP>Use <I>g</I> as the name for the global IDL scope (default
<TT>_GlobalIDL</TT>).</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbpackage=</TT><I>p</I></TD><TD ALIGN=left NOWRAP>Put both Python modules and stub files in package
<I>p</I>.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbmodules=</TT><I>p</I></TD><TD ALIGN=left NOWRAP>Put Python modules in package <I>p</I>.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbstubs=</TT><I>p</I></TD><TD ALIGN=left NOWRAP>Put stub files in package <I>p</I>.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
</TD></TR>
</TABLE><P>The <TT>-Wbstdout</TT> option is not really useful if you are
invoking omniidl yourself. It is used by <TT>omniORB.importIDL()</TT>,
described in section&#XA0;<A HREF="#sec:importIDL">4.9</A>.</P><P>When you compile an IDL file which #includes other IDL files, omniidl
normally only generates code for the main file, assuming that code for
the included files will be generated separately. Instead, you can use
the <TT>-Wbinline</TT> option to generate code for the main IDL file
<EM>and</EM> all included files in a single stub file.</P><P>Definitions declared at IDL global scope are normally placed in a
Python module named &#X2018;<TT>_GlobalIDL</TT>&#X2019;. The <TT>-Wbglobal</TT>
allows you to change that.</P><P>As explained in section&#XA0;<A HREF="#sec:generatingStubs">2.2</A>, when you compile an
IDL file like:</P><DIV CLASS="lstlisting"><I>// example_echo.idl</I>
<B>module</B> Example {
  <B>interface</B> Echo {
    <B>string</B> echoString(<B>in</B> <B>string</B> mesg);
  };
};</DIV><P>omniidl generates directories named <TT>Example</TT> and
<TT>Example__POA</TT>, which provide the standard Python mapping
modules, and also the file <TT>example_echo_idl.py</TT> which contains
the actual definitions. The latter file contains code which inserts
the definitions in the standard modules. This arrangement means that
it is not possible to move all of the generated code into a Python
package by simply placing the files in a suitably named directory.
You may wish to do this to avoid clashes with names in use elsewhere
in your software.</P><P>You can place all generated code in a package using the
<TT>-Wbpackage</TT> command line option. For example,</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bpython -Wbpackage=generated echo_example.idl</TT>
</BLOCKQUOTE><P>creates a directory named &#X2018;<TT>generated</TT>&#X2019;, containing the
generated code. The stub module is now called
&#X2018;<TT>generated.Example</TT>&#X2019;, and the actual stub definitions are in
&#X2018;<TT>generated.example_echo_idl</TT>&#X2019;. If you wish to split the
modules and the stub definitions into different Python packages, you
can use the <TT>-Wbmodules</TT> and <TT>-Wbstubs</TT> options.</P><P>Note that if you use these options to change the module package, the
interface to the generated code is not strictly-speaking CORBA
compliant. You may have to change your code if you ever use a Python
ORB other than omniORBpy.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc64">5.3</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>Generate the Python stubs for a file <TT>a.idl</TT>:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bpython a.idl</TT>
</BLOCKQUOTE><P>As above, but put the stubs in a package called
&#X2018;<TT>stubs</TT>&#X2019;:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bpython -Wbstubs=stubs a.idl</TT>
</BLOCKQUOTE><P>Generate both Python and C++ stubs for two IDL files:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bpython -bcxx a.idl b.idl</TT>
</BLOCKQUOTE><P>Just check the IDL files for validity, generating no output:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl a.idl b.idl</TT>
</BLOCKQUOTE><!--TOC chapter Interoperable Naming Service-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc65">Chapter&#XA0;6</A>&#XA0;&#XA0;Interoperable Naming Service</H1><!--SEC END --><P>
<A NAME="chap:ins"></A></P><P>omniORB supports the Interoperable Naming Service (INS). The following
is a summary of its facilities.</P><!--TOC section Object URIs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">6.1</A>&#XA0;&#XA0;Object URIs</H2><!--SEC END --><P>As well as accepting IOR-format strings, <TT>orb.string_to_object()</TT>
now also supports two new Uniform Resource Identifier
(URI)&#XA0;[<A HREF="#rfc2396">BLFIM98</A>] formats, which can be used to specify objects in
a convenient human-readable form. The existing IOR-format strings are
now also considered URIs.</P><!--TOC subsection corbaloc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">6.1.1</A>&#XA0;&#XA0;corbaloc</H3><!--SEC END --><P><TT>corbaloc</TT> URIs allow you to specify object references which
can be contacted by IIOP, or found through
<TT>ORB::resolve_initial_references()</TT>. To specify an IIOP object
reference, you use a URI of the form:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:iiop:</TT>&lt;<I>host</I>&gt;<TT>:</TT>&lt;<I>port</I>&gt;<TT>/</TT>&lt;<I>object key</I>&gt;
</BLOCKQUOTE><P>for example:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:iiop:myhost.example.com:1234/MyObjectKey</TT>
</BLOCKQUOTE><P>which specifies an object with key &#X2018;MyObjectKey&#X2019; within a
process running on myhost.example.com listening on port 1234. Object
keys containing non-ASCII characters can use the standard URI %
escapes:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:iiop:myhost.example.com:1234/My</TT><TT>%</TT><TT>efObjectKey</TT>
</BLOCKQUOTE><P>denotes an object key with the value 239 (hex ef) in the
third octet.</P><P>The protocol name &#X2018;<TT>iiop</TT>&#X2019; can be abbreviated to the empty
string, so the original URI can be written:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::myhost.example.com:1234/MyObjectKey</TT>
</BLOCKQUOTE><P>The IANA has assigned port number 2809<SUP><A NAME="text11" HREF="#note11">1</A></SUP> for use by <TT>corbaloc</TT>, so if
the server is listening on that port, you can leave the port number
out. The following two URIs refer to the same object:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::myhost.example.com:2809/MyObjectKey</TT><BR>
<TT>corbaloc::myhost.example.com/MyObjectKey</TT>
</BLOCKQUOTE><P>You can specify an object which is available at more than
one location by separating the locations with commas:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::myhost.example.com,:localhost:1234/MyObjectKey</TT>
</BLOCKQUOTE><P>Note that you must restate the protocol for each address,
hence the &#X2018;<TT>:</TT>&#X2019; before &#X2018;<TT>localhost</TT>&#X2019;. It could
equally have been written &#X2018;<TT>iiop:localhost</TT>&#X2019;.</P><P>You can also specify an IIOP version number:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::1.2@myhost.example.com/MyObjectKey</TT>
</BLOCKQUOTE><P>Specifying IIOP versions above 1.0 is slightly risky since higher
versions make use of various information stored in IORs that is not
present in a corbaloc URI. It is generally best to contact initial
corbaloc objects with IIOP 1.0, and rely on higher versions for all
other object references.</P><P>Alternatively, to use <TT>resolve_initial_references()</TT>, you
use a URI of the form:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:rir:/NameService</TT>
</BLOCKQUOTE><!--TOC subsection corbaname-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">6.1.2</A>&#XA0;&#XA0;corbaname</H3><!--SEC END --><P>
<A NAME="sec:corbaname"></A></P><P><TT>corbaname</TT> URIs cause <TT>string_to_object()</TT> to look-up a
name in a CORBA Naming service. They are an extension of the
<TT>corbaloc</TT> syntax:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname:</TT>&lt;<I>corbaloc location</I>&gt;<TT>/</TT>&lt;<I>object key</I>&gt;<TT>#</TT>&lt;<I>stringified name</I>&gt;
</BLOCKQUOTE><P>for example:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname::myhost/NameService#project/example/echo.obj</TT><BR>
<TT>corbaname:rir:/NameService#project/example/echo.obj</TT>
</BLOCKQUOTE><P>The object found with the <TT>corbaloc</TT>-style portion
must be of type <TT>CosNaming::NamingContext</TT>, or something
derived from it. If the object key (or <TT>rir</TT> name) is
&#X2018;<TT>NameService</TT>&#X2019;, it can be left out:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname::myhost#project/example/echo.obj</TT><BR>
<TT>corbaname:rir:#project/example/echo.obj</TT>
</BLOCKQUOTE><P>The stringified name portion can also be left out, in which
case the URI denotes the <TT>CosNaming::NamingContext</TT> which would
have been used for a look-up:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname::myhost.example.com</TT><BR>
<TT>corbaname:rir:</TT>
</BLOCKQUOTE><P>The first of these examples is the easiest way of specifying
the location of a naming service.</P><!--TOC section Configuring resolve_initial_references-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc69">6.2</A>&#XA0;&#XA0;Configuring resolve_initial_references</H2><!--SEC END --><P>
<A NAME="sec:insargs"></A></P><P>The INS specifies two standard command line arguments which provide a
portable way of configuring <TT>ORB::resolve_initial_references()</TT>:</P><!--TOC subsection ORBInitRef-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">6.2.1</A>&#XA0;&#XA0;ORBInitRef</H3><!--SEC END --><P><TT>-ORBInitRef</TT> takes an argument of the form
&lt;<I>ObjectId</I>&gt;<TT>=</TT>&lt;<I>ObjectURI</I>&gt;. So, for example,
with command line arguments of:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBInitRef NameService=corbaname::myhost.example.com</TT>
</BLOCKQUOTE><P><TT>resolve_initial_references("NameService")</TT> will
return a reference to the object with key &#X2018;NameService&#X2019; available on
myhost.example.com, port 2809. Since IOR-format strings are considered
URIs, you can also say things like:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBInitRef NameService=IOR:00ff...</TT>
</BLOCKQUOTE><!--TOC subsection ORBDefaultInitRef-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">6.2.2</A>&#XA0;&#XA0;ORBDefaultInitRef</H3><!--SEC END --><P><TT>-ORBDefaultInitRef</TT> provides a prefix string which is used to
resolve otherwise unknown names. When
<TT>resolve_initial_references()</TT> is unable to resolve a name which
has been specifically configured (with <TT>-ORBInitRef</TT>), it
constructs a string consisting of the default prefix, a &#X2018;<TT>/</TT>&#X2019;
character, and the name requested. The string is then fed to
<TT>string_to_object()</TT>. So, for example, with a command line of:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBDefaultInitRef corbaloc::myhost.example.com</TT>
</BLOCKQUOTE><P>a call to <TT>resolve_initial_references("MyService")</TT>
will return the object reference denoted by
&#X2018;<TT>corbaloc::myhost.example.com/MyService</TT>&#X2019;.</P><P>Similarly, a <TT>corbaname</TT> prefix can be used to cause
look-ups in the naming service. Note, however, that since a
&#X2018;<TT>/</TT>&#X2019; character is always added to the prefix, it is
impossible to specify a look-up in the root context of the naming
service&#X2014;you have to use a sub-context, like:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBDefaultInitRef corbaname::myhost.example.com#services</TT>
</BLOCKQUOTE><!--TOC section omniNames-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc72">6.3</A>&#XA0;&#XA0;omniNames</H2><!--SEC END --><!--TOC subsection NamingContextExt-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc73">6.3.1</A>&#XA0;&#XA0;NamingContextExt</H3><!--SEC END --><P>omniNames supports the <TT>CosNaming::NamingContextExt</TT> interface:</P><DIV CLASS="lstlisting"><B>module</B> CosNaming {
  <B>interface</B> NamingContextExt : NamingContext {
    <B>typedef</B> <B>string</B> StringName;
    <B>typedef</B> <B>string</B> Address;
    <B>typedef</B> <B>string</B> URLString;

    StringName  to_string(<B>in</B> Name n)        <B>raises</B>(InvalidName);
    Name        to_name  (<B>in</B> StringName sn) <B>raises</B>(InvalidName);

    <B>exception</B> InvalidAddress {};

    URLString   to_url(<B>in</B> Address addr, <B>in</B> StringName sn)
      <B>raises</B>(InvalidAddress, InvalidName);

    <B>Object</B>      resolve_str(<B>in</B> StringName n)
      <B>raises</B>(NotFound, CannotProceed, InvalidName, AlreadyBound);
  };
};</DIV><P><TT>to_string()</TT> and <TT>to_name()</TT> convert from <TT>CosNaming::Name</TT>
sequences to flattened strings and vice-versa. Calling these
operations involves remote calls to the naming service, so they are
not particularly efficient. The <TT>omniORB.URI</TT> module contains
equivalent <TT>nameToString()</TT> and <TT>stringToName()</TT> functions, which do
not involve remote calls.</P><P>A <TT>CosNaming::Name</TT> is stringified by separating name components
with &#X2018;<TT>/</TT>&#X2019; characters. The <TT>kind</TT> and <TT>id</TT> fields of
each component are separated by &#X2018;<TT>.</TT>&#X2019; characters. If the
<TT>kind</TT> field is empty, the representation has no trailing
&#X2018;<TT>.</TT>&#X2019;; if the <TT>id</TT> is empty, the representation starts
with a &#X2018;<TT>.</TT>&#X2019; character; if both <TT>id</TT> and <TT>kind</TT>
are empty, the representation is just a &#X2018;<TT>.</TT>&#X2019;. The backslash
&#X2018;<TT>\</TT>&#X2019; is used to escape the meaning of
&#X2018;<TT>/</TT>&#X2019;, &#X2018;<TT>.</TT>&#X2019; and &#X2018;<TT>\</TT>&#X2019; itself.</P><P><TT>to_url()</TT> takes a <TT>corbaloc</TT> style address and key string
(but without the <TT>corbaloc:</TT> part), and a stringified name,
and returns a <TT>corbaname</TT> URI (incorrectly called a URL)
string, having properly escaped any invalid characters. The
specification does not make it clear whether or not the address string
should also be escaped by the operation; omniORB does not escape
it. For this reason, it is best to avoid calling <TT>to_url()</TT> if the
address part contains escapable characters. The local function
<TT>omniORB.URI.addrAndNameToURI()</TT> is equivalent.</P><P><TT>resolve_str()</TT> is equivalent to calling <TT>to_name()</TT> followed by
the inherited <TT>resolve()</TT> operation. There are no string-based
equivalents of the various bind operations.</P><!--TOC subsection Use with corbaname-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">6.3.2</A>&#XA0;&#XA0;Use with corbaname</H3><!--SEC END --><P>To make it easy to use omniNames with <TT>corbaname</TT> URIs, it
starts with the default port of 2809, and an object key of
&#X2018;<TT>NameService</TT>&#X2019; for the root naming context.</P><!--TOC section omniMapper-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc75">6.4</A>&#XA0;&#XA0;omniMapper</H2><!--SEC END --><P>omniMapper is a simple daemon which listens on port 2809 (or any other
port), and redirects IIOP requests for configured object keys to
associated persistent IORs. It can be used to make a naming service
(even an old non-INS aware version of omniNames or other ORB&#X2019;s naming
service) appear on port 2809 with the object key
&#X2018;<TT>NameService</TT>&#X2019;. The same goes for any other service you may
wish to specify, such as an interface repository. omniMapper is
started with a command line of:</P><BLOCKQUOTE CLASS="quote">
<TT>omniMapper [-port </TT>&lt;<I>port</I>&gt;<TT>] [-config </TT>&lt;<I>config file</I>&gt;<TT>] [-v]</TT>
</BLOCKQUOTE><P>The <TT>-port</TT> option allows you to choose a port other
than 2809 to listen on. The <TT>-config</TT> option specifies a
location for the configuration file. The default name is
<TT>/etc/omniMapper.cfg</TT>, or <TT>C:\omniMapper.cfg</TT> on
Windows. omniMapper does not normally print anything; the <TT>-v</TT>
option makes it verbose so it prints configuration information and a
record of the redirections it makes, to standard output.</P><P>The configuration file is very simple. Each line contains a string to
be used as an object key, some white space, and an IOR (or any valid
URI) that it will redirect that object key to. Comments should be
prefixed with a &#X2018;<TT>#</TT>&#X2019; character. For example:</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim"># Example omniMapper.cfg
NameService         IOR:000f...
InterfaceRepository IOR:0100...
</PRE></BLOCKQUOTE><P>omniMapper can either be run on a single machine, in much the same way
as omniNames, or it can be run on <EM>every</EM> machine, with a common
configuration file. That way, each machine&#X2019;s omniORB configuration
file could contain the line:</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim">ORBDefaultInitRef corbaloc::localhost
</PRE></BLOCKQUOTE><!--TOC section Creating objects with simple object keys-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">6.5</A>&#XA0;&#XA0;Creating objects with simple object keys</H2><!--SEC END --><P>In normal use, omniORB creates object keys containing various
information including POA names and various non-ASCII characters.
Since object keys are supposed to be opaque, this is not usually a
problem. The INS breaks this opacity and requires servers to create
objects with human-friendly keys.</P><P>If you wish to make your objects available with human-friendly URIs,
there are two options. The first is to use omniMapper as described
above, in conjunction with a <TT>PERSISTENT</TT> POA. The second is to
create objects with the required keys yourself. You do this with a
special POA with the name &#X2018;<TT>omniINSPOA</TT>&#X2019;, acquired from
<TT>resolve_initial_references()</TT>. This POA has the <TT>USER_ID</TT>
and <TT>PERSISTENT</TT> policies, and the special property that the
object keys it creates contain only the object ids given to the POA,
and no other data. It is a normal POA in all other respects, so you
can activate/deactivate it, create children, and so on, in the usual
way.</P><P>Children of the omniINSPOA do not inherit its special properties of
creating simple object keys. If the omniINSPOA&#X2019;s policies are not
suitable for your application, you cannot create a POA with different
policies (such as single threading, for example), and still generate
simple object keys. Instead, you can activate a servant in the
omniINSPOA that uses location forwarding to redirect requests to
objects in a different POA.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note11" HREF="#text11">1</A></DT><DD CLASS="dd-thefootnotes">Not 2089 as
printed in [<A HREF="#inschapters">OMG00</A>]!
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Connection and Thread Management-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc77">Chapter&#XA0;7</A>&#XA0;&#XA0;Connection and Thread Management</H1><!--SEC END --><P>
<A NAME="chap:connections"></A></P><P>This chapter describes how omniORB manages threads and network
connections.</P><!--TOC section Background-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc78">7.1</A>&#XA0;&#XA0;Background</H2><!--SEC END --><P>In CORBA, the ORB is the &#X2018;middleware&#X2019; that allows a client to invoke
an operation on an object without regard to its implementation or
location. In order to invoke an operation on an object, a client needs
to &#X2018;bind&#X2019; to the object by acquiring its object reference. Such a
reference may be obtained as the result of an operation on another
object (such as a naming service or factory object) or by conversion
from a stringified representation. If the object is in a different
address space, the binding process involves the ORB building a proxy
object in the client&#X2019;s address space. The ORB arranges for invocations
on the proxy object to be transparently mapped to equivalent
invocations on the implementation object.</P><P>For the sake of interoperability, CORBA mandates that all ORBs should
support IIOP as the means to communicate remote invocations over a
TCP/IP connection. IIOP is usually<SUP><A NAME="text12" HREF="#note12">1</A></SUP>
asymmetric with respect to the roles of the parties at the two ends of
a connection. At one end is the client which can only initiate remote
invocations. At the other end is the server which can only receive
remote invocations.</P><P>Notice that in CORBA, as in most distributed systems, remote bindings
are established implicitly without application intervention. This
provides the illusion that all objects are local, a property known as
&#X2018;location transparency&#X2019;. CORBA does not specify when such bindings
should be established or how they should be multiplexed over the
underlying network connections. Instead, ORBs are free to implement
implicit binding by a variety of means.</P><P>The rest of this chapter describes how omniORB manages network
connections and the programming interface to fine tune the management
policy.</P><!--TOC section The model-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc79">7.2</A>&#XA0;&#XA0;The model</H2><!--SEC END --><P>omniORB is designed from the ground up to be fully multi-threaded. The
objective is to maximise the degree of concurrency and at the same
time eliminate any unnecessary thread overhead. Another objective is
to minimise the interference by the activities of other threads on the
progress of a remote invocation. In other words, thread &#X2018;cross-talk&#X2019;
should be minimised within the ORB. To achieve these objectives, the
degree of multiplexing at every level is kept to a minimum by default.</P><P>Minimising multiplexing works well when the ORB is relatively lightly
loaded. However, when the ORB is under heavy load, it can sometimes be
beneficial to conserve operating system resources such as threads and
network connections by multiplexing at the ORB level. omniORB has
various options that control its multiplexing behaviour.</P><!--TOC section Client side behaviour-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc80">7.3</A>&#XA0;&#XA0;Client side behaviour</H2><!--SEC END --><P>On the client side of a connection, the thread that invokes on a proxy
object drives the GIOP protocol directly and blocks on the connection
to receive the reply. The first time the client makes a call to a
particular address space, the ORB opens a suitable connection to the
remote address space (based on the client transport rule as described
in section&#XA0;<A HREF="#sec:clientRule">7.7.1</A>). After the reply has been received,
the ORB caches the open network connection, ready for use by another
call.</P><P>If two (or more) threads in a multi-threaded client attempt to contact
the same address space simultaneously, there are two different ways to
proceed. The default way is to open another network connection to the
server. This means that neither the client or server ORB has to
perform any multiplexing on the network connections&#X2014;multiplexing is
performed by the operating system, which has to deal with multiplexing
anyway. The second possibility is for the client to multiplex the
concurrent requests on a single network connection. This conserves
operating system resources (network connections), but means that both
the client and server have to deal with multiplexing issues
themselves.</P><P>In the default one call per connection mode, there is a limit to the
number of concurrent connections that are opened, set with the
<TT>maxGIOPConnectionPerServer</TT> parameter. To tell the ORB
that it may multiplex calls on a single connection, set the
<TT>oneCallPerConnection</TT> parameter to zero. If the
<TT>oneCallPerConnection</TT> parameter is set to the default
value of one, and there are more concurrent calls than specified by
<TT>maxGIOPConnectionPerServer</TT>, calls block waiting for connections
to become free.</P><P>Note that some server-side ORBs, including omniORB versions before
version 4.0, are unable to deal with concurrent calls multiplexed on a
single connection, so they serialise the calls. It is usually best to
keep to the default mode of opening multiple connections.</P><!--TOC subsection Client side timeouts-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">7.3.1</A>&#XA0;&#XA0;Client side timeouts</H3><!--SEC END --><P>
<A NAME="sec:timeoutAPI"></A></P><P>omniORB can associate a timeout with a call, meaning that if the call
takes too long a <TT>TRANSIENT</TT> exception is thrown. Timeouts can be
set for the whole process, for a specific thread, or for a specific
object reference.</P><P>Timeouts are set using functions in the <TT>omniORB</TT> module:</P><DIV CLASS="lstlisting">omniORB.setClientCallTimeout(millisecs)
omniORB.setClientCallTimeout(objref, millisecs)
omniORB.setClientThreadCallTimeout(millisecs)
omniORB.setClientConnectTimeout(millisecs)</DIV><P><TT>setClientCallTimeout()</TT> sets either the global timeout or the
timeout for a specific object reference.
<TT>setClientThreadCallTimeout()</TT> sets the timeout for the calling
thread. Setting any timeout value to zero disables it.</P><P>Accessing per-thread state is a relatively expensive operation, so per
thread timeouts are disabled by default. The
<TT>supportPerThreadTimeOut</TT> parameter must be set true to enable
them.</P><P>To choose the timeout value to use for a call, the ORB first looks to
see if there is a timeout for the object reference, then to the
calling thread, and finally to the global timeout.</P><P>When a client has no existing connection to communicate with a server,
it must open a new connection before performing the
call. <TT>setClientConnectTimeout()</TT> sets an overriding timeout for
cases where a new connection must be established. The effect of the
connect timeout depends upon whether the connect timeout is greater
or less than the timeout that would otherwise be used.</P><P>As an example, imagine that the usual call timeout is 10 seconds:</P><!--TOC subsubsection Connect timeout &gt; usual timeout-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Connect timeout &gt; usual timeout</H4><!--SEC END --><P>If the connect timeout is set to 20 seconds, then a call that
establishes a new connection will be permitted 20 seconds before it
times out. Subsequent calls using the same connection have the normal
10 second timeout. If establishing the connection takes 8 seconds,
then the call itself takes 5 seconds, the call succeeds despite having
taken 13 seconds in total, longer than the usual timeout.</P><P>This kind of configuration is good when connections are slow to be
established.</P><P>If an object reference has multiple possible endpoints available, and
connecting to the first endpoint times out, only that one endpoint
will have been tried before an exception is raised. However, once the
timeout has occurred, the object reference will switch to use the next
endpoint. If the application attempts to make another call, it will
use the next endpoint.</P><!--TOC subsubsection Connect timeout &lt; usual timeout-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Connect timeout &lt; usual timeout</H4><!--SEC END --><P>If the connect timeout is set to 2 seconds, the actual network-level
connect is only permitted to take 2 seconds. As long as the connection
is established in less than 2 seconds, the call can proceed. The 10
second call timeout still applies to the time taken for the whole call
(including the connection establishment). So, if establishing the
connection takes 1.5 seconds, and the call itself takes 9.5 seconds,
the call will time out because although it met the connection timeout,
it exceeded the 10 second total call timeout. On the other hand, if
establishing the connection takes 3 seconds, the call will fail after
only 2 seconds, since only 2 seconds are permitted for the connect.</P><P>If an object reference has multiple possible endpoints available, the
client will attempt to connect to them in turn, until one succeeds.
The connect timeout applies to each connection attempt. So with a
connect timeout of 2 seconds, the client will spend up to 2 seconds
attempting to connect to the first address and then, if that fails, up
to 2 seconds trying the second address, and so on. The 10 second
timeout still applies to the call as a whole, so if the total time
taken on timed-out connection attempts exceeds 10 seconds, the call
will time out.</P><P>This kind of configuration is useful where calls may take a long time
to complete (so call timeouts are long), but a fast indication of
connection failure is required.</P><!--TOC section Server side behaviour-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc82">7.4</A>&#XA0;&#XA0;Server side behaviour</H2><!--SEC END --><P>The server side has two primary modes of operation: thread per
connection and thread pooling. It is able to dynamically transition
between the two modes, and it supports a hybrid scheme that behaves
mostly like thread pooling, but has the same fast turn-around for
sequences of calls as thread per connection.</P><!--TOC subsection Thread per connection mode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">7.4.1</A>&#XA0;&#XA0;Thread per connection mode</H3><!--SEC END --><P>In thread per connection mode (the default, and the only option in
omniORB versions before 4.0), each connection has a single thread
dedicated to it. The thread blocks waiting for a request. When it
receives one, it unmarshals the arguments, makes the up-call to the
application code, marshals the reply, and goes back to watching the
connection. There is thus no thread switching along the call chain,
meaning the call is very efficient.</P><P>As explained above, a client can choose to multiplex multiple
concurrent calls on a single connection, so once the server has
received the request, and just before it makes the call into
application code, it marks the connection as &#X2018;selectable&#X2019;, meaning
that another thread should watch it to see if any other requests
arrive. If they do, extra threads are dispatched to handle the
concurrent calls. GIOP 1.2 actually allows the argument data for
multiple calls to be interleaved on a connection, so the unmarshalling
code has to handle that too. As soon as any multiplexing occurs on the
connection, the aim of removing thread switching cannot be met, and
there is inevitable inefficiency due to thread switching.</P><P>The <TT>maxServerThreadPerConnection</TT> parameter can be set to limit
the number of threads that can be allocated to a single connection
containing concurrent calls. Setting the parameter to 1 mimics the
behaviour of omniORB versions before 4.0, that did not support
calls multiplexed on one connection.</P><!--TOC subsection Thread pool mode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">7.4.2</A>&#XA0;&#XA0;Thread pool mode</H3><!--SEC END --><P>
<A NAME="sec:watchConn"></A></P><P>In thread pool mode, selected by setting the
<TT>threadPerConnectionPolicy</TT> parameter to zero, a single thread
watches all incoming connections. When a call arrives on one of them,
a thread is chosen from a pool of threads, and set to work
unmarshalling the arguments and performing the up-call. There is
therefore at least one thread switch for each call.</P><P>The thread pool is not pre-initialised. Instead, threads are started
on demand, and idle threads are stopped after a period of inactivity.
The maximum number of threads that can be started in the pool is set
with the <TT>maxServerThreadPoolSize</TT> parameter. The default
is 100.</P><P>A common pattern in CORBA applications is for a client to make several
calls to a single object in quick succession. To handle this situation
most efficiently, the default behaviour is to not return a thread to
the pool immediately after a call is finished. Instead, it is set to
watch the connection it has just served for a short while, mimicking
the behaviour in thread per connection mode. If a new call comes in
during the watching period, the call is dispatched without any thread
switching, just as in thread per connection mode. Of course, if the
server is supporting a very large number of connections (more than the
size of the thread pool), this policy can delay a call coming from
another connection. If the <TT>threadPoolWatchConnection</TT>
parameter is set to zero, connection watching is disabled and threads
return to the pool immediately after finishing a single request.</P><P>In the face of multiplexed calls on a single connection, multiple
threads from the pool can be dispatched for one connection, just as in
thread per connection mode. With <TT>threadPoolWatchConnection</TT> set
to the default value of 1, only the last thread servicing a connection
will watch it when it finishes a request. Setting the parameter to a
larger number allows the last <EM>n</EM> connections to watch the
connection.</P><!--TOC subsection Policy transition-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">7.4.3</A>&#XA0;&#XA0;Policy transition</H3><!--SEC END --><P>If the server is dealing with a relatively small number of
connections, it is most efficient to use thread per connection mode.
If the number of connections becomes too large, however, operating
system limits on the number of threads may cause a significant
slowdown, or even prevent the acceptance of new connections
altogether.</P><P>To give the most efficient response in all circumstances, omniORB
allows a server to start in thread per connection mode, and transition
to thread pooling if many connections arrive. This is controlled with
the <TT>threadPerConnectionUpperLimit</TT> and
<TT>threadPerConnectionLowerLimit</TT> parameters. The former must
always be larger than the latter. The upper limit chooses the number
of connections at which time the ORB transitions to thread pool mode;
the lower limit selects the point at which the transition back to
thread per connection is made.</P><P>For example, setting the upper limit to 50 and the lower limit to 30
would mean that the first 49 connections would receive dedicated
threads. The 50th to arrive would trigger thread pooling. All future
connections to arrive would make use of threads from the pool. Note
that the existing dedicated threads continue to service their
connections until the connections are closed. If the number of
connections falls below 30, thread per connection is reactivated and
new connections receive their own dedicated threads (up to the limit
of 50 again). Once again, existing connections in thread pool mode
stay in that mode until they are closed.</P><!--TOC section Idle connection shutdown-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc86">7.5</A>&#XA0;&#XA0;Idle connection shutdown</H2><!--SEC END --><P>
<A NAME="sec:connShutdown"></A></P><P>It is wasteful to leave a connection open when it has been left unused
for a considerable time. Too many idle connections could block out new
connections when it runs out of spare communication channels. For
example, most platforms have a limit on the number of file handles a
process can open. Many platforms have a very small default limit like
64. The value can often be increased to a maximum of a thousand or
more by changing the &#X2018;ulimit&#X2019; in the shell.</P><P>Every so often, a thread scans all open connections to see which are
idle. The scanning period (in seconds) is set with the
<TT>scanGranularity</TT> parameter. The default is 5 seconds.</P><P>Outgoing connections (initiated by clients) and incoming connections
(initiated by servers) have separate idle timeouts. The timeouts are
set with the <TT>outConScanPeriod</TT> and <TT>inConScanPeriod</TT>
parameters respectively. The values are in seconds, and must be a
multiple of the scan granularity.</P><P>Beware that setting <TT>outConScanPeriod</TT> or <TT>inConScanPeriod</TT>
to be equal to (or less than) <TT>scanGranularity</TT> means that
connections are considered candidates for closure immediately after
they are opened. That can mean that the connections are closed before
any calls have been sent through them. If oneway calls are used, such
connection closure can result in silent loss of calls.</P><!--TOC subsection Interoperability Considerations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">7.5.1</A>&#XA0;&#XA0;Interoperability Considerations</H3><!--SEC END --><P>The IIOP specification allows both the client and the server to
shutdown a connection unilaterally. When one end is about to shutdown
a connection, it should send a CloseConnection message to the other
end. It should also make sure that the message will reach the other
end before it proceeds to shutdown the connection.</P><P>The client should distinguish between an orderly and an abnormal
connection shutdown. When a client receives a CloseConnection message
before the connection is closed, the condition is an orderly shutdown.
If the message is not received, the condition is an abnormal shutdown.
In an abnormal shutdown, the ORB should raise a <TT>COMM_FAILURE</TT>
exception whereas in an orderly shutdown, the ORB should <EM>not</EM>
raise an exception and should try to re-establish a new connection
transparently.</P><P>omniORB implements these semantics completely. However, it is known
that some ORBs are not (yet) able to distinguish between an orderly
and an abnormal shutdown. Usually this is manifested as the client in
these ORBs seeing a <TT>COMM_FAILURE</TT> occasionally when connected
to an omniORB server. The work-around is either to catch the exception
in the application code and retry, or to turn off the idle connection
shutdown inside the omniORB server.</P><!--TOC section Transports and endpoints-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc88">7.6</A>&#XA0;&#XA0;Transports and endpoints</H2><!--SEC END --><P>omniORB can support multiple network transports. All platforms
(usually) have a TCP transport available. Unix platforms support a
Unix domain socket transport. Platforms with the OpenSSL library
available can support an SSL transport.</P><P>Servers must be configured in two ways with regard to transports: the
transports and interfaces on which they listen, and the details that
are published in IORs for clients to see. Usually the published
details will be the same as the listening details, but there are times
when it is useful to publish different information.</P><P>Details are selected with the <TT>endPoint</TT> family of parameters.
The simplest is plain <TT>endPoint</TT>, which chooses a transport and
interface details, and publishes the information in IORs. Endpoint
parameters are in the form of URIs, with a scheme name of
&#X2018;<TT>giop:</TT>&#X2019;, followed by the transport name. Different transports
have different parameters following the transport.</P><P>TCP endpoints have the format:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp:</TT><I>&lt;host&gt;</I><TT>:</TT><I>&lt;port&gt;</I>
</BLOCKQUOTE><P>The host must be a valid host name or IP address for the
server machine. It determines the network interface on which the
server listens. The port selects the TCP port to listen on, which must
be unoccupied. Either the host or port, or both can be left empty. If
the host is empty, the ORB publishes the IP address of the first
non-loopback network interface it can find (or the loopback if that is
the only interface), but listens on <EM>all</EM> network interfaces. If
the port is empty, the operating system chooses a port.</P><P>Multiple TCP endpoints can be selected, either to specify multiple
network interfaces on which to listen, or (less usefully) to select
multiple TCP ports on which to listen.</P><P>If no <TT>endPoint</TT> parameters are set, the ORB assumes a single
parameter of <TT>giop:tcp::</TT>, meaning IORs contain the address of
the first non-loopback network interface, the ORB listens on all
interfaces, and the OS chooses a port number.</P><P>SSL endpoints have the same format as TCP ones, except &#X2018;<TT>tcp</TT>&#X2019;
is replaced with &#X2018;<TT>ssl</TT>&#X2019;. Unix domain socket endpoints have the
format:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:unix:</TT><I>&lt;filename&gt;</I>
</BLOCKQUOTE><P>where the filename is the name of the socket within the
filesystem. If the filename is left blank, the ORB chooses a name
based on the process id and a timestamp.</P><P>To listen on an endpoint without publishing it in IORs, specify it
with the <TT>endPointNoPublish</TT> configuration parameter. See below
for more details about endpoint publishing.</P><!--TOC subsection IPv6-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">7.6.1</A>&#XA0;&#XA0;IPv6</H3><!--SEC END --><P>On platforms where it is available, omniORB supports IPv6. On most
Unix platforms, IPv6 sockets accept both IPv6 and IPv4 connections, so
omniORB&#X2019;s default <TT>giop:tcp::</TT> endpoint accepts both IPv4 and
IPv6 connections. On Windows versions before Windows Vista, each
socket type only accepts incoming connections of the same type, so an
IPv6 socket cannot be used with IPv4 clients. For this reason, the
default <TT>giop:tcp::</TT> endpoint only listens for IPv4 connections.
Since endpoints with a specific host name or address only listen on a
single network interface, they are inherently limited to just one
protocol family.</P><P>To explicitly ask for just IPv4 or just IPv6, an endpoint with the
wildcard address for the protocol family should be used. For IPv4, the
wildcard address is &#X2018;<TT>0.0.0.0</TT>&#X2019;, and for IPv6 it is &#X2018;<TT>::</TT>&#X2019;.
So, to listen for IPv4 connections on all IPv4 network interfaces, use
an endpoint of:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp:0.0.0.0:</TT>
</BLOCKQUOTE><P>All IPv6 addresses contain colons, so the address portion in
URIs must be contained within <TT>[]</TT> characters. Therefore, to
listen just for IPv6 connections on all IPv6 interfaces, use the
somewhat cryptic:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp:[::]:</TT>
</BLOCKQUOTE><P>To listen for both IPv4 and IPv6 connections on Windows
versions prior to Vista, both endpoints must be explicitly provided.</P><!--TOC subsection Endpoint publishing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">7.6.2</A>&#XA0;&#XA0;Endpoint publishing</H3><!--SEC END --><P>For clients to be able to connect to a server, the server publishes
endpoint information in its IORs (Interoperable Object References).
Normally, omniORB publishes the first available address for each of
the endpoints it is listening on.</P><P>The endpoint information to publish is determined by the
<TT>endPointPublish</TT> configuration parameter. It contains a
comma-separated list of publish rules. The rules are applied in turn
to each of the configured endpoints; if a rule matches an endpoint, it
causes one or more endpoints to be published.</P><P>The following core rules are supported:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>addr</TT></TD><TD VALIGN=top ALIGN=left>the first natural address of the endpoint</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>ipv4</TT></TD><TD VALIGN=top ALIGN=left>the first IPv4 address of a TCP or SSL endpoint</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>ipv6</TT></TD><TD VALIGN=top ALIGN=left>the first IPv6 address of a TCP or SSL endpoint</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>name</TT></TD><TD VALIGN=top ALIGN=left>the first address that can be resolved to a name</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>hostname</TT></TD><TD VALIGN=top ALIGN=left>the result of the gethostname() system call</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>fqdn</TT></TD><TD VALIGN=top ALIGN=left>the fully-qualified domain name</TD></TR>
</TABLE><P>The core rules can be combined using the vertical bar operator to
try several rules in turn until one succeeds. e.g:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>name|ipv6|ipv4</TT></TD><TD VALIGN=top ALIGN=left>the name of the endpoint if it has one;
	failing that, its first IPv6 address;
	failing that, its first IPv4 address.</TD></TR>
</TABLE><P>Multiple rules can be combined using the comma operator to
publish more than one endpoint. e.g.</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>name,addr</TT></TD><TD VALIGN=top ALIGN=left>the name of the endpoint (if it has one),
followed by its first address.</TD></TR>
</TABLE><P>For endpoints with multiple addresses (e.g. TCP endpoints on
multi-homed machines), the <TT>all()</TT> manipulator causes all
addresses to be published. e.g.:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>all(addr)</TT></TD><TD VALIGN=top ALIGN=left>all addresses are published</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name)</TT></TD><TD VALIGN=top ALIGN=left>all addresses that resolve to names are published</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name|addr)</TT></TD><TD VALIGN=top ALIGN=left>all addresses are published by name if they have
one, address otherwise.</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name,addr)</TT></TD><TD VALIGN=top ALIGN=left>all addresses are published by name (if they
have one), and by address.</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name), all(addr)</TT></TD><TD VALIGN=top ALIGN=left>first the names of all addresses are published,
followed by all the addresses.</TD></TR>
</TABLE><P>A specific endpoint can be published by giving its endpoint URI,
even if the server is not listening on that endpoint. e.g.:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>giop:tcp:not.my.host:12345</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>giop:unix:/not/my/socket-file</TT></TD></TR>
</TABLE><P>If the host or port number for a TCP or SSL URI are missed out,
they are filled in with the details from each listening TCP/SSL
endpoint. This can be used to publish a different name for a
TCP/SSL endpoint that is using an ephemeral port, for example.</P><P>omniORB 4.0 supported two options related to endpoint publishing that
are superseded by the <TT>endPointPublish</TT> parameter, and so are now
deprecated. Setting <TT>endPointPublishAllIFs</TT> to 1 is equivalent to
setting <TT>endPointPublish</TT> to &#X2018;<TT>all(addr)</TT>&#X2019;. The
<TT>endPointNoListen</TT> parameter is equivalent to adding endpoint
URIs to the <TT>endPointPublish</TT> parameter.</P><!--TOC section Connection selection and acceptance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">7.7</A>&#XA0;&#XA0;Connection selection and acceptance</H2><!--SEC END --><P>In the face of IORs containing details about multiple different
endpoints, clients have to know how to choose the one to use to
connect a server. Similarly, servers may wish to restrict which
clients can connect to particular transports. This is achieved with
<I>transport rules</I>.</P><!--TOC subsection Client transport rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc92">7.7.1</A>&#XA0;&#XA0;Client transport rules</H3><!--SEC END --><P>
<A NAME="sec:clientRule"></A></P><P>The <TT>clientTransportRule</TT> parameter is used to filter and
prioritise the order in which transports specified in an IOR are
tried. Each rule has the form:</P><BLOCKQUOTE CLASS="quote">
<I>&lt;address mask&gt; [action]+</I>
</BLOCKQUOTE><P>The address mask can be one of</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>1.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>localhost</TT></TD><TD VALIGN=top ALIGN=left>The address of this machine</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
2.</TD><TD VALIGN=top ALIGN=left NOWRAP><I>w.x.y.z</I><TT>/</TT><I>m1.m2.m3.m4</I></TD><TD VALIGN=top ALIGN=left>An IPv4 address
with bits selected by the mask, e.g.
 <TT>172.16.0.0/255.240.0.0</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
3.</TD><TD VALIGN=top ALIGN=left NOWRAP><I>w.x.y.z</I><TT>/</TT><I>prefixlen</I></TD><TD VALIGN=top ALIGN=left>An IPv4 address with
<I>prefixlen</I> significant bits, e.g.
 <TT>172.16.2.0/24</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
4.</TD><TD VALIGN=top ALIGN=left NOWRAP><I>a:b:c:d:e:f:g:h</I><TT>/</TT><I>prefixlen</I></TD><TD VALIGN=top ALIGN=left>An IPv6
address with <I>prefixlen</I> significant bits, e.g.
 <TT>3ffe:505:2:1::/64</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
5.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>*</TT></TD><TD VALIGN=top ALIGN=left>Wildcard that matches any address</TD></TR>
</TABLE><P>The action is one or more of the following:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>1.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>none</TT></TD><TD VALIGN=top ALIGN=left>Do not use this address</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>2.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>tcp</TT></TD><TD VALIGN=top ALIGN=left>Use a TCP transport</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>3.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>ssl</TT></TD><TD VALIGN=top ALIGN=left>Use an SSL transport</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>4.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>unix</TT></TD><TD VALIGN=top ALIGN=left>Use a Unix socket transport</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>5.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>bidir</TT></TD><TD VALIGN=top ALIGN=left>Connections to this address can be used
bidirectionally (see section&#XA0;<A HREF="#sec:bidir">7.8</A>)</TD></TR>
</TABLE><P>The transport-selecting actions form a prioritised list, so
an action of &#X2018;<TT>unix,ssl,tcp</TT>&#X2019; means to use a Unix transport if
there is one, failing that a SSL transport, failing <EM>that</EM> a TCP
transport. In the absence of any explicit rules, the client uses the
implicit rule of &#X2018;<TT>* unix,ssl,tcp</TT>&#X2019;.</P><P>If more than one rule is specified, they are prioritised in the order
they are specified. For example, the configuration file might contain:</P><PRE CLASS="verbatim">  clientTransportRule = 192.168.1.0/255.255.255.0  unix,tcp
  clientTransportRule = 172.16.0.0/255.240.0.0     unix,tcp
                      =       *                    none
</PRE><P>This would be useful if there is a fast network
(192.168.1.0) which should be used in preference to another network
(172.16.0.0), and connections to other networks are not permitted at
all.</P><P>In general, the result of filtering the endpoint specifications in an
IOR with the client transport rule will be a prioritised list of
transports and networks. (If the transport rules do not prioritise one
endpoint over another, the order the endpoints are listed in the IOR
is used.) When trying to contact an object, the ORB tries its
possible endpoints in turn, until it finds one with which it can
contact the object. Only after it has unsuccessfully tried all
permissible endpoints will it raise a <TT>TRANSIENT</TT> exception to
indicate that the connect failed.</P><!--TOC subsection Server transport rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">7.7.2</A>&#XA0;&#XA0;Server transport rules</H3><!--SEC END --><P>
<A NAME="sec:serverRule"></A></P><P>The server transport rules have the same format as client transport
rules. Rather than being used to select which of a set of ways to
contact a machine, they are used to determine whether or not to accept
connections from particular clients. In this example, we only allow
connections from our intranet:</P><PRE CLASS="verbatim">  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          none
</PRE><P>And in this one, we accept only SSL connections if the
client is not on the intranet:</P><PRE CLASS="verbatim">  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          ssl,bidir
</PRE><P>In the absence of any explicit rules, the server uses the
implicit rule of &#X2018;<TT>* unix,ssl,tcp</TT>&#X2019;, meaning any kind of
connection is accepted from any client.</P><!--TOC section Bidirectional GIOP-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc94">7.8</A>&#XA0;&#XA0;Bidirectional GIOP</H2><!--SEC END --><P>
<A NAME="sec:bidir"></A></P><P>omniORB supports bidirectional GIOP, which allows callbacks to be made
using a connection opened by the original client, rather than the
normal model where the server opens a new connection for the callback.
This is important for negotiating firewalls, since they tend not to
allow connections back on arbitrary ports.</P><P>There are several steps required for bidirectional GIOP to be enabled
for a callback. Both the client and server must be configured
correctly. On the client side, these conditions must be met:</P><UL CLASS="itemize"><LI CLASS="li-itemize">The <TT>offerBiDirectionalGIOP</TT> parameter must be set to true. 
</LI><LI CLASS="li-itemize">The client transport rule for the target server must contain the
<TT>bidir</TT> action.
</LI><LI CLASS="li-itemize">The POA containing the callback object (or objects) must have
been created with a <TT>BidirectionalPolicy</TT> value of
<TT>BOTH</TT>.</LI></UL><P>On the server side, these conditions must be met:</P><UL CLASS="itemize"><LI CLASS="li-itemize">The <TT>acceptBiDirectionalGIOP</TT> parameter must be set to true. 
</LI><LI CLASS="li-itemize">The server transport rule for the requesting client must contain
the <TT>bidir</TT> action.
</LI><LI CLASS="li-itemize">The POA hosting the object contacted by the client must have
been created with a <TT>BidirectionalPolicy</TT> value of
<TT>BOTH</TT>.</LI></UL><!--TOC section SSL transport-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc95">7.9</A>&#XA0;&#XA0;SSL transport</H2><!--SEC END --><P>omniORB supports an SSL transport, using OpenSSL. It is only built if
OpenSSL is available. On platforms using Autoconf, it is autodetected
in many locations, or its location can be given with the
<TT>--with-openssl=</TT> argument to <TT>configure</TT>. On other
platforms, the <TT>OPEN_SSL_ROOT</TT> make variable must be set in the
platform file.</P><P>To use the SSL transport from Python you must import and set
parameters in the <TT>omniORB.sslTP</TT> module before calling
<TT>CORBA.ORB_init()</TT>. To initialise the module, you must call the
<TT>certificate_authority_file()</TT>, <TT>key_file()</TT> and
<TT>key_file_password()</TT> functions, providing the file names of the
certificate authority and encryption keys, and the key file password.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note12" HREF="#text12">1</A></DT><DD CLASS="dd-thefootnotes">GIOP 1.2 supports
&#X2018;bidirectional GIOP&#X2019;, which permits the r&#XF4;les to be reversed.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Code set conversion-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc96">Chapter&#XA0;8</A>&#XA0;&#XA0;Code set conversion</H1><!--SEC END --><P>
<A NAME="chap:codesets"></A></P><P>omniORB supports full code set negotiation, used to select and
translate between different character code sets, for the transmission
of chars, strings, wchars and wstrings. The support is mostly
transparent to application code, but there are a number of options
that can be selected. This chapter covers the options, and also gives
some pointers about how to implement your own code sets, in case the
ones that come with omniORB are not sufficient.</P><!--TOC section Native code set-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc97">8.1</A>&#XA0;&#XA0;Native code set</H2><!--SEC END --><P>For the ORB to know how to handle strings given to it by the
application, it must know what code set they are represented with, so
it can properly translate them if need be. The default is ISO 8859-1
(Latin 1). A different code sets can be chosen at initialisation time
with the <TT>nativeCharCodeSet</TT> parameter. The supported code sets
are printed out at initialisation time if the ORB traceLevel is 15 or
greater.</P><P>For most applications, the default is fine. Some applications may need
to set the native char code set to UTF-8, allowing the full Unicode
range to be supported in strings.</P><P>In omniORBpy, wchar and wstring are always represented by the Python
Unicode type, so there is no need to select a native code set for
wchar.</P><!--TOC section Code set library-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc98">8.2</A>&#XA0;&#XA0;Code set library</H2><!--SEC END --><P>To save space in the main ORB core library, most of the code set
implementations are in a separate library. To load it from Python, you
must import the <TT>omniORB.codesets</TT> module before calling
<TT>CORBA.ORB_init()</TT>.</P><!--TOC section Implementing new code sets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">8.3</A>&#XA0;&#XA0;Implementing new code sets</H2><!--SEC END --><P>Code sets must currently be implemented in C++. See the omniORB for
C++ documentation for details.</P><!--TOC chapter Interceptors-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc100">Chapter&#XA0;9</A>&#XA0;&#XA0;Interceptors</H1><!--SEC END --><P>
<A NAME="chap:interceptors"></A></P><P>omniORBpy has limited interceptor support. Interceptors permit the
application to insert processing at various points along the call
chain, as requests are processed. The Portable Interceptors API is not
yet supported.</P><P>Interceptors are registered using functions in the
<TT>omniORB.interceptors</TT> module:</P><DIV CLASS="lstlisting">  addClientSendRequest()
  addClientReceiveReply()
  addServerReceiveRequest()
  addServerSendReply()
  addServerSendException()</DIV><P>To register an interceptor function, call the relevant registration
function with a callable argument. The callable will be called with
two or three arguments. The first argument is the name of the
operation being invoked; the second is the set of service contexts to
be retrieved or filled in. <TT>ServerSendException</TT> has a third
argument, the repository id of the exception being thrown.</P><P>When receiving service contexts (in the <TT>ClientReceiveReply</TT> and
<TT>ServerReceiveRequest</TT> interceptors), the second argument
is a tuple of 2-tuples. In each 2-tuple, the first item is the service
context id and the second item is the CDR encapsulation of the service
context. The encapsulation can be decoded with
<TT>omniORB.cdrUnmarshal()</TT> (but only if you know the type to decode it
to).</P><P>When sending service contexts (<TT>ClientSendRequest</TT>,
<TT>ServerSendReply</TT>, and <TT>ServerSendException</TT>), the second
argument is an empty list. The interceptor function can choose to add
one or more service context tuples, with the same form described
above, by appending to the list. Encapsulations are created with
<TT>omniORB.cdrMarshal()</TT>.</P><P>Interceptor registration functions may only be called before the ORB
is initialised. Attempting to call them later results in a
<TT>BAD_INV_ORDER</TT> exception.</P><!--TOC chapter Objects by value-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc101">Chapter&#XA0;10</A>&#XA0;&#XA0;Objects by value</H1><!--SEC END --><P>
<A NAME="chap:valuetype"></A></P><P>omniORBpy 3 supports objects by value, declared with the
<TT>valuetype</TT> keyword in IDL. This chapter outlines some issues to
do with using valuetypes in omniORB. You are assumed to have read the
relevant parts of the CORBA specification, specifically chapters 4 and
5 of the CORBA 2.6 specification, and section 1.3.10 of the Python
language mapping, version 1.2.</P><!--TOC section Features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc102">10.1</A>&#XA0;&#XA0;Features</H2><!--SEC END --><P>omniORB supports the complete objects by value specification, with the
exception of custom valuetypes. All other features including value
boxes, value sharing semantics, abstract valuetypes, and abstract
interfaces are supported.</P><!--TOC section Value sharing and local calls-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">10.2</A>&#XA0;&#XA0;Value sharing and local calls</H2><!--SEC END --><P>When valuetypes are passed as parameters in CORBA calls (i.e. calls
on CORBA objects declared with <TT>interface</TT> in IDL), the structure
of related values is maintained. Consider, for example, the following
IDL definitions (which are from the example code in
<TT>src/examples/valuetype/simple</TT>:</P><DIV CLASS="lstlisting"><B>module</B> ValueTest {
  <B>valuetype</B> One {
    <B>public</B> <B>string</B> s;
    <B>public</B> <B>long</B>   l;
  };

  <B>interface</B> Test {
    One op1(<B>in</B> One a, <B>in</B> One b);
  };
};</DIV><P>If the client to the <TT>Test</TT> object passes the same value in both
parameters, just one value is transmitted, and the object
implementation receives a copy of the single value, with references to
it in both parameters.</P><P>In the case that the object is remote from the client, there is
obviously a copying step involved. In the case that the object is in
the same address space as the client, the same copying semantics must
be maintained so that the object implementation can modify the values
it receives without the client seeing the modifications. To support
that, omniORB must copy the entire parameter list in one operation, in
case there is sharing between different parameters. Such copying is a
rather more time-consuming process than the parameter-by-parameter
copy that takes place in calls not involving valuetypes.</P><P>To avoid the overhead of copying parameters in this way, applications
can choose to relax the semantics of value copying in local calls, so
values are not copied at all, but are passed by reference. In that
case, the client to a call <EM>will</EM> see any modifications to the
values it passes as parameters (and similarly, the object
implementation will see any changes the client makes to returned
values). To choose this option, set the <TT>copyValuesInLocalCalls</TT>
configuration parameter to zero.</P><!--TOC section Value factories-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc104">10.3</A>&#XA0;&#XA0;Value factories</H2><!--SEC END --><P>As specified in section 1.3.10 of the Python language mapping (version
1.2), factories are automatically registered for values with no
operations. This means that in common usage where values are just used
to hold state, the application code does not need to implement and
register factories. The application may still register different
factories if it requires.</P><P>If the IDL definitions specify operations on values, the application
is supposed to provide implementations of the operations, meaning that
it must register suitable factories. If the application chooses to
ignore the operations and just manipulate the data inside the values,
omniidl can be asked to register factories for <EM>all</EM> values, not
just ones with no operations, using the <TT>-Wbfactories</TT> option.</P><P>The Python language mapping says a value factory should be &#X201C;a class
instance with a <TT>__call__</TT> method taking no arguments&#X201D;.
omniORBpy is less restrictive than that, and permits the use of
<EM>any</EM> callable object, in particular the value implementation
class itself.</P><!--TOC section Standard value boxes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc105">10.4</A>&#XA0;&#XA0;Standard value boxes</H2><!--SEC END --><P>The standard <TT>CORBA.StringValue</TT> and <TT>CORBA.WStringValue</TT>
value boxes are available to application code. To make the definitions
available in IDL, #include the standard <TT>orb.idl</TT>.</P><!--TOC section Values inside Anys-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc106">10.5</A>&#XA0;&#XA0;Values inside Anys</H2><!--SEC END --><P>Valuetypes inserted into Anys cause a number of interesting issues.
Even when inside Anys, values are required to support complete sharing
semantics. Take this IDL for example:</P><DIV CLASS="lstlisting"><B>module</B> ValueTest {
  <B>valuetype</B> One {
    <B>public</B> <B>string</B> s;
    <B>public</B> <B>long</B>   l;
  };

  <B>interface</B> AnyTest {
    <B>void</B> op1(<B>in</B> One v, <B>in</B> Any a);
  };
};</DIV><P>Now, suppose the client behaves as follows:</P><DIV CLASS="lstlisting">v = One_impl("hello", 123)
a = CORBA.Any(ValueTest._tc_One, v)
obj.op1(v, a)</DIV><P>then on the server side:</P><DIV CLASS="lstlisting"><B>class</B> AnyTest_impl:
    ...
    <B>def</B> op1(self, v, a):
        v2 = a.value()
        assert v2 == v</DIV><P>This is all very well in this kind of simple situation, but problems
can arise if truncatable valuetypes are used. Imagine this derived
value:</P><DIV CLASS="lstlisting"><B>module</B> ValueTest {
  <B>valuetype</B> Two : <B>truncatable</B> One {
    <B>public</B> <B>double</B> d;
  };
};</DIV><P>Now, suppose that the client shown above sends an instance of
valuetype <TT>Two</TT> in both parameters, and suppose that the server
has not seen the definition of valuetype <TT>Two</TT>. In this
situation, as the first parameter is unmarshalled, it will be
truncated to valuetype <TT>One</TT>, as required. Now, when the Any is
unmarshalled, it refers to the same value, which has been truncated.
So, even though the TypeCode in the Any indicates that the value has
type <TT>Two</TT>, the stored value actually has type <TT>One</TT>. If the
receiver of the Any tries to pass it on, transmission will fail
because the Any&#X2019;s value does not match its TypeCode.</P><P>In the opposite situation, where an Any parameter comes before a
valuetype parameter, a different problem occurs. In that case, as the
Any is unmarshalled, there is no type information available for
valuetype <TT>Two</TT>, so omniORBpy constructs a suitable type based on
the transmitted TypeCode. Because omniORBpy is unable to know how (and
indeed if) the application has implemented valuetype <TT>One</TT>, the
generated class for valuetype <TT>Two</TT> is not derived from the
application&#X2019;s <TT>One</TT> class. When the second parameter is
unmarshalled, it is given as an indirection to the
previously-marshalled value inside the Any. The parameter is therefore
set to the constructed <TT>Two</TT> type, rather than being truncated to
an instance of the application&#X2019;s registered <TT>One</TT> type.</P><P>Because of these issues, it is best to avoid defining interfaces that
mix valuetypes and Anys in a single operation, and certainly to avoid
trying to share plain values with values inside Anys.</P><!--TOC chapter References-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->References</H1><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="rfc2396"><FONT COLOR=purple>[BLFIM98]</FONT></A></DT><DD CLASS="dd-thebibliography">
T. Berners-Lee, R. Fielding, U.C. Irvine, and L. Masinter.
<EM>U</EM><EM>niform </EM><EM>R</EM><EM>esource </EM><EM>I</EM><EM>dentifiers (</EM><EM>URI</EM><EM>): Generic Syntax</EM>.
RFC 2396, August 1998.</DD><DT CLASS="dt-thebibliography"><A NAME="corbaservices"><FONT COLOR=purple>[OMG98]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>CORBAServices</EM><EM>: Common Object Services Specification</EM>, December
1998.</DD><DT CLASS="dt-thebibliography"><A NAME="inschapters"><FONT COLOR=purple>[OMG00]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>Interoperable Naming Service revised chapters</EM>, August 2000.
From <A HREF="http://www.omg.org/cgi-bin/doc?ptc/00-08-07"><TT>http://www.omg.org/cgi-bin/doc?ptc/00-08-07</TT></A>.</DD><DT CLASS="dt-thebibliography"><A NAME="corba26-spec"><FONT COLOR=purple>[OMG01a]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>The </EM><EM>C</EM><EM>ommon </EM><EM>O</EM><EM>bject </EM><EM>R</EM><EM>equest </EM><EM>B</EM><EM>roker: </EM><EM>A</EM><EM>rchitecture and
Specification</EM>, 2.6 edition, December 2001.
From <A HREF="http://www.omg.org/cgi-bin/doc?formal/01-12-01"><TT>http://www.omg.org/cgi-bin/doc?formal/01-12-01</TT></A>.</DD><DT CLASS="dt-thebibliography"><A NAME="pythonmapping"><FONT COLOR=purple>[OMG01b]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>Python Language Mapping Specification</EM>, February 2001.
<A HREF="http://www.omg.org/technology/documents/formal/python.htm"><TT>http://www.omg.org/technology/documents/formal/python.htm</TT></A>.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
